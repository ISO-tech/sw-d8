<?php

use Drupal\Core\Block\BlockPluginInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityManagerInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Link;
use Drupal\Core\Render\Element;
use Drupal\Core\Routing;
use Drupal\Core\Url;

use Drupal\media\Entity\Media;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\TermInterface;
use Drupal\user\Entity\User;
use Drupal\views\ViewExecutable;

use Drupal\sw\DraftToLive;
use Drupal\sw\Plugin\Block\SWTodaysStoriesBlock;

const SW_SECTION_EDITORIALS_TID = 11;
const SW_SECTION_READERS_VIEWS_TID = 9;
const SW_SECTION_OBRERO_SOCIALISTA_TID = 17255;
const SW_SECTION_LABOR_TID = 7;
const SW_SECTION_ACTIVIST_NEWS_TID = 8;

const SW_INSERT_BOX_TYPE_CUSTOM_TID = 256;
const SW_INSERT_BOX_TYPE_COLUMNIST_TID = 262;
const SW_INSERT_BOX_TYPE_REVIEW_TID = 265;
const SW_INSERT_BOX_TYPE_SERIES_TID = 267;

const SW_STORY_TYPE_CUSTOM_TID = 391;
const SW_STORY_TYPE_INTERVIEW_TID = 393;
const SW_STORY_TYPE_OBITUARY_TID = 4556;
const SW_STORY_TYPE_ROUNDTABLE_TID = 2922;

const SW_TOPIC_NONE_TID = 412;

/**
 * Implements hook_form_FORM_ID_alter() for 'taxonomy_overview_terms'.
 *
 * Inject a 'TID' column into the term overview page.
 */
function sw_form_taxonomy_overview_terms_alter(&$form, FormStateInterface $form_state) {
  $form['terms']['#header'][] = t('TID');
  foreach (Element::children($form['terms']) as $id) {
    $form['terms'][$id]['tid_display'] = [
      '#type' => 'markup',
      '#markup' => $form['terms'][$id]['#term']->id(),
    ];
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'views_bulk_operations_configure_action'.
 */
function sw_form_views_bulk_operations_configure_action_alter(&$form, FormStateInterface $form_state) {
  $form_data = $form_state->get('views_bulk_operations');
  if (!empty($form_data['view_id']) && $form_data['view_id'] == 'sw_admin_bulk_edit_story') {
    foreach (['langcode', 'revision_log'] as $key) {
      $form['node']['story'][$key]['#access'] = FALSE;
      $form['node']['story']['_field_selector'][$key]['#access'] = FALSE;
    }
    // And put the checkboxes for 'Main topic' and 'Secondary topic' at the top.
    foreach (['field_topic' => -100, 'field_secondary_topic' => -99] as $key => $weight) {
      $form['node']['story']['_field_selector'][$key]['#weight'] = $weight;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'media_image_add_form'.
 */
function sw_form_media_image_add_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _sw_form_media_image_form_alter($form, $form_state, $form_id);
}

/**
 * Implements hook_form_FORM_ID_alter() for 'media_image_edit_form'.
 */
function sw_form_media_image_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _sw_form_media_image_form_alter($form, $form_state, $form_id);
}

/**
 * Helper function for shared altering for media image forms (add and edit).
 */
function _sw_form_media_image_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['field_original_image']['#states'] = [
    'visible' => [
      ':input[name="field_image_crop_type"]' => ['value' => 1],
    ],
  ];
}

/**
 * Implements hook_form_FORM_ID_alter() for 'node_form'.
 *
 * Invokes bundle-specific methods to alter node forms.
 */
function sw_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $node = $form_state->getFormObject()->getEntity();
  switch ($node->bundle()) {
    case 'story':
      sw_story_node_form_alter($form, $form_state, $form_id);
      break;

    case 'insert_box':
      sw_insert_box_node_form_alter($form, $form_state, $form_id);
      break;

  }
}

/**
 * Helper for hook_form_FORM_ID_alter() for story nodes.
 *
 * Improves the UI by only conditionally showing relevant fields based on the
 * values of other fields via #states, and hiding fields we don't want to see.
 */
function sw_story_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['field_kicker']['#states'] = [
    'visible' => [
      ':input[name="field_kicker[0][value]"]' => ['filled' => TRUE],
    ],
  ];
  $form['field_interviewees']['#states'] = [
    'visible' => [
      ':input[name="field_story_type"]' => [
        ['value' => SW_STORY_TYPE_INTERVIEW_TID],
        ['value' => SW_STORY_TYPE_OBITUARY_TID],
      ],
    ],
  ];
  $form['field_story_label']['#states'] = [
    'visible' => [
      ':input[name="field_story_type"]' => ['value' => SW_STORY_TYPE_CUSTOM_TID],
    ],
  ];

  // Set #pre_render to hide filter format guidelines on all text areas.
  foreach (['field_teaser', 'field_body', 'field_introduction', 'field_body_introduction'] as $field) {
    $form[$field]['#pre_render'][] = 'sw_hide_format_guidelines_form_pre_render';
  }
}

/**
 * #pre_render callback to hide all the text area filter format guidelines.
 */
function sw_hide_format_guidelines_form_pre_render(array $element) {
  if (!empty($element['widget'][0]['format']['guidelines'])) {
    $element['widget'][0]['format']['guidelines']['#access'] = FALSE;
  }
  return $element;
}

/**
 * Helper for hook_form_FORM_ID_alter() for insert_box nodes.
 *
 * Improves the UI by only conditionally showing relevant fields based on the
 * values of other fields via #states.
 */
function sw_insert_box_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['title']['widget'][0]['value']['#description'] = t('This field is just for administrators to give insert boxes more meaningful names. For example, this is useful when browsing for the box to insert in a given story.');
  $form['field_header_text']['#states'] = [
    'visible' => [
      ':input[name="field_insert_type"]' => [
        ['value' => SW_INSERT_BOX_TYPE_CUSTOM_TID],
        ['value' => SW_INSERT_BOX_TYPE_COLUMNIST_TID],
        ['value' => SW_INSERT_BOX_TYPE_REVIEW_TID],
        ['value' => SW_INSERT_BOX_TYPE_SERIES_TID],
      ],
    ],
  ];
  $form['field_insert_body']['#pre_render'][] = 'sw_hide_format_guidelines_form_pre_render';
}

/**
 * Implements hook_preprocess_HOOK() for taxonomy terms.
 */
function sw_preprocess_taxonomy_term(&$variables) {
  // If we're on one of our term-driven story lists, tell the twig template to
  // think we're a full-page view so we don't print a duplicate label + link.
  $view_id = \Drupal::routeMatch()->getParameter('view_id');
  if (!empty($view_id)) {
    switch ($view_id) {
      case 'sw_section_stories':
      case 'sw_series_stories':
      case 'sw_topic_stories':
      case 'sw_issue_stories':
        $variables['page'] = TRUE;
        break;

    }
  }
}

/**
 * Implements hook_preprocess_HOOK() for nodes.
 *
 * For now, we're only processing stories, but that'll change. Instead of
 * stuffing everything into a giant function, call bundle-specific functions.
 */
function sw_preprocess_node(&$variables) {
  switch ($variables['node']->getType()) {
    case 'story':
      sw_preprocess_node_story($variables);
      break;

    case 'insert_box':
      sw_preprocess_node_insert_box($variables);
      break;
  }
}

/**
 * Preprocess function for story nodes.
 *
 * Inject the correct story_label based on the complex logic.
 *
 * On full view mode, also rewrites introduction and body_introduction to
 * replace %author and %interviewee.
 *
 * Handles the display-friendly version of field_contributors (sorts
 * alphabetically based on last name, adds appropriate delimiters and puts it
 * all on a single line.).
 *
 * For the teaser-conditional-image view mode, hides images on stories that
 * don't have weight -8 or lighter.
 */
function sw_preprocess_node_story(&$variables) {
  // For any view mode, we're going to need to load the authors (and
  // interviewee) if any. For teasers, we'll need them for the story label.
  // For full view, we'll also need them to rewrite '%author' (and perhaps
  // %interviewee) in the introduction. So, we load all these target entities
  // once, and stash them into the $node object for re-use.
  foreach (['authors', 'interviewees'] as $field_id) {
    sw_load_referenced_entities($variables['node'], $field_id, ['Drupal\node\Entity\Node', 'loadMultiple']);
  }

  $variables['story_label'] = sw_get_story_label($variables['node'], $variables['view_mode']);

  if ($variables['view_mode'] == 'full' || $variables['view_mode'] == 'forward') {
    if (!empty($variables['node']->sw_authors)) {
      $placeholders['%author'] = sw_get_entity_label_multiple($variables['node']->sw_authors, 'sw_author_label');
    }
    if (!empty($variables['node']->sw_interviewees)) {
      $placeholders['%interviewee'] = sw_get_entity_label_multiple($variables['node']->sw_interviewees, 'sw_subject_label');
    }
    if (!empty($placeholders)) {
      foreach (['field_introduction', 'field_body_introduction'] as $intro_field) {
        if (!empty($variables['content'][$intro_field][0]['#text'])) {
          $variables['content'][$intro_field][0]['#text'] = strtr($variables['content'][$intro_field][0]['#text'], $placeholders);
        }
      }
    }
    sw_load_referenced_entities($variables['node'], 'contributors', ['Drupal\taxonomy\Entity\Term', 'loadMultiple']);
    if (!empty($variables['node']->sw_contributors)) {
      uasort($variables['node']->sw_contributors, 'sw_contributor_sort');
      $variables['content']['contributors'] = [
        '#prefix' => '<div class="contributors">',
        '#markup' => sw_get_entity_label_multiple($variables['node']->sw_contributors, 'sw_plain_label') . t(' contributed to this article.'),
        '#suffix' => '</div>',
        '#weight' => '100',
      ];
    }
    $series = sw_get_series_term($variables['node']);
    if (!empty($series)) {
      $variables['series_navigation'] = sw_get_series_navigation($variables['node'], $series);
    }
  }

  if ($variables['view_mode'] == 'teaser_conditional_image') {
    // Hide main_image based on story_weight.
    $weight = $variables['node']->get('field_story_weight')->getValue();
    $main_image = $variables['node']->get('field_main_image')->getValue();
    // -7 and heavier is "greater than" in the math world. This logic seems
    // backwards, but it's right given the inverted meaning of weights.
    // However, even for important stories (-8 and "above"), don't set the
    // "...-with-image" class if there's no value for field_main_image.
    if ($weight[0]['value'] > -8 || empty($main_image)) {
      unset($variables['content']['field_main_image']);
      $variables['attributes']['class'][] = 'teaser-conditional-no-image';
    }
    else {
      $variables['attributes']['class'][] = 'teaser-conditional-with-image';
    }

    // See if we're on a story list where the story labels don't make sense.
    // Since the story label is conditional on the page we're viewing, the
    // resulting render array can only be cached per route/page.
    $variables['#cache']['contexts'][] = 'route';
    $route_parameters = \Drupal::routeMatch()->getParameters();
    if ($route_parameters) {
      $view_id = $route_parameters->get('view_id');
      if (!empty($view_id) && $view_id == 'sw_section_stories') {
        $arg_0 = $route_parameters->get('arg_0');
        if (!empty($arg_0)) {
          switch (strtolower($arg_0)) {
            case 'editorials':
            case "readers'-views":
            case 'obrero-socialista':
              // @todo It'd be better not to compute these in the first place...
              unset($variables['story_label']);
              break;
          }
        }
      }
      elseif (!empty($view_id) && $view_id == 'sw_recent') {
        unset($variables['date']);
      }
      elseif (!empty($view_id) && $view_id == 'sw_series_stories') {
        // Sort of ugly. It's not easy to get the currently active View object
        // to inquire directly about the taxonomy argument it's using. Call a
        // helper method to find the term given a URL argument.
        $arg_0 = $route_parameters->get('arg_0');
        $term = sw_get_term_from_path('series', $arg_0);
        if (!empty($term)) {
          // Since this render array is dependent upon fields on the taxonomy
          // term, add it to the #cache tags.
          $variables['#cache']['tags'][] = 'taxonomy_term:' . $term->id();
          // If the term doesn't want story labels, hide them.
          if (empty($term->get('field_show_story_labels')->value)) {
            unset($variables['story_label']);
          }
        }
      }
      else {
        $node = $route_parameters->get('node');
        if (!empty($node) && $node->getType() == 'person') {
          if ($variables['story_label'] == $node->getTitle()) {
            unset($variables['story_label']);
          }
        }
      }
    }
  }

}

/**
 * Preprocess function for insert_box nodes.
 *
 * Replace the title (which is only for admins) with the display-appropriate title.
 * The display title is based on insert type, and optionally header_text.
 */
function sw_preprocess_node_insert_box(&$variables) {
  $insert_type = $variables['node']->get('field_insert_type')->entity;
  $header_text = $variables['node']->get('field_header_text')->value;
  $insert_title = $insert_type->label();

  switch ($insert_type->id()) {
    // If there's custom text, put the 'Series' part in a separate variable for
    // the twig template and use the custom text as the full label.
    case SW_INSERT_BOX_TYPE_SERIES_TID:
      if (!empty($header_text)) {
        $variables['insert_box_label'] = [
          // @todo: Should this be a more semantically accurate class name?
          '#prefix' => '<div class="story-label">',
          '#markup' => $insert_title,
          '#suffix' => '</div>',
        ];
        $insert_title = $header_text;
      }
      break;

    // Set the insert box title to only what's in the header text.
    case SW_INSERT_BOX_TYPE_CUSTOM_TID:
      if (!empty($header_text)) {
        $insert_title = $header_text;
      }
      break;

    // Append the header text to the term name as the insert box title.
    case SW_INSERT_BOX_TYPE_COLUMNIST_TID:
    case SW_INSERT_BOX_TYPE_REVIEW_TID:
      if (!empty($header_text)) {
        $insert_title .= ': ' . $header_text;
      }
      break;

  }
  $variables['label'] = $insert_title;
}

/**
 * Load entities pointed to via an entity_reference field into the host entity.
 *
 * The array of loaded entities is stuffed into the host entity at the 'sw_'
 * namespace, and will be keyed by entity IDs (as returned by whatever version
 * of Entity::loadMultiple() is passed in).
 *
 * @param EntityInterface $entity
 *   The host entity with an entity_reference field that points to the
 *   entities to load.
 * @param string $field_id
 *   Identifier for the entity_reference field to use (without the 'field_' prefix).
 * @param callable $load_multiple_function
 *   A callable static method that will load multiple entities given an array of IDs.
 *   For example, "['Drupal\taxonomy\Entity\Term', 'loadMultiple']" to load terms or
 *   "['Drupal\node\Entity\Node', 'loadMultiple']" to load nodes.
 *
 * @see \Drupal\Core\Entity\Entity::loadMultiple()
 */
function sw_load_referenced_entities(EntityInterface $entity, $field_id, $load_multiple_function) {
  $targets = $entity->get('field_' . $field_id)->getValue();
  if (!empty($targets)) {
    foreach ($targets as $target) {
      $target_ids[] = $target['target_id'];
    }
    $entity->{'sw_' . $field_id} = $load_multiple_function($target_ids);
  }
}

function sw_contributor_sort($a, $b) {
  $a_name_parts = explode(' ', $a->label());
  $b_name_parts = explode(' ', $b->label());
  return strcmp(array_pop($a_name_parts), array_pop($b_name_parts));
}

/**
 * Label callback to return the plain entity label.
 */
function sw_plain_label(EntityInterface $entity) {
  return $entity->label();
};

/**
 * Label callback that wraps the entity label with author-specific markup.
 */
function sw_author_label(EntityInterface $entity) {
  return '<span class="sw-author">' . $entity->toLink()->toString() . '</span>';
};

/**
 * Label callback that wraps the entity label with subject-specific markup.
 *
 * Used for interviewee, obituary, etc.
 */
function sw_subject_label(EntityInterface $entity) {
  return '<span class="sw-subject">' . $entity->toLink()->toString() . '</span>';
};

/**
 * Generate the appropriate story label for a given story.
 *
 *  Pseudocode for the logic is as follows:
 *  if (section exists && section != ‘Movement News’) {
 *    $story_label = $section_name;
 *  }
 *  elseif (story type is interview || obituary ) {
 *    Story label = “$story_type: $interviewees” // (not the $authors)
 *  }
 *  elseif (story type is roundtable or custom) {
 *    Story label = the story type
 *  }
 *  elseif (story has authors ) {
 *    Story label = $author(s)
 *  }
 *  else {
 *    // no story label
 *  }
 *
 * @param \Drupal\node\NodeInterface $node
 *   A story node entity to generate the story label for.
 *
 * @param string $view_mode
 *   The view mode we're displaying the story with.
 *
 * @return string
 *   The story label (basically, the "byline") for the story.
 */
function sw_get_story_label(NodeInterface $node, $view_mode) {
  $story_label = '';

  $use_markup = $view_mode === 'full';

  $section = $node->get('field_section')->getValue();
  $story_type = $node->get('field_story_type')->getValue();

  if (!empty($section[0]['target_id'])) {
    switch ($section[0]['target_id']) {
      case SW_SECTION_EDITORIALS_TID:
        $story_label = t('Editorial');
        break;

      case SW_SECTION_READERS_VIEWS_TID:
        $story_label = t("Readers’ View");
        break;

      case SW_SECTION_OBRERO_SOCIALISTA_TID:
        $story_label = t('Obrero Socialista');
        break;
    }
  }

  if (empty($story_label) && !empty($story_type[0]['target_id'])) {
    switch ($story_type[0]['target_id']) {
      case SW_STORY_TYPE_INTERVIEW_TID:
        $story_label = t('Interview');
        $target_field = 'sw_interviewees';
        break;

      case SW_STORY_TYPE_OBITUARY_TID:
        $story_label = t('Obituary');
        $target_field = 'sw_interviewees';
        break;

      case SW_STORY_TYPE_ROUNDTABLE_TID:
        $story_label = t('Roundtable');
        break;

      case SW_STORY_TYPE_CUSTOM_TID:
        $story_label = $node->get('field_story_label')->value;
        break;
    }
  }

  // Some stories are set as 'Interview' or 'Obituary' that don't define a
  // subject person. We have to handle that. If there are subject(s) defined,
  // add ': ' to the label before their name(s).
  if (!empty($target_field) && $target_field == 'sw_interviewees') {
    if (empty($node->sw_interviewees)) {
      $target_field = '';
    }
    else {
      $story_label .= ': ';
      $label_func = $use_markup ? 'sw_subject_label' : 'sw_plain_label';
    }
  }

  // Nothing special from section or story type, use the author(s) (if any).
  if (empty($story_label) && !empty($node->sw_authors)) {
    $target_field = 'sw_authors';
    $label_func = $use_markup ? 'sw_author_label' : 'sw_plain_label';
  }

  if (!empty($target_field)) {
    $story_label .= sw_get_entity_label_multiple($node->{$target_field}, $label_func);
  }

  // If all else fails, provide a fallback since we never want an empty story label.
  if (empty($story_label)) {
    $story_label = t('Report');
  }

  return $story_label;
}

/**
 * Returns an appropriate label given an array of entities.
 *
 * If there's only 1 entity, return the label.
 * If 2, use "LabelA and LabelB".
 * If 3 or more "Label1, ... LabelN-1 and LabelN".
 *
 * @param array $entities
 *   An array of objects that implement \Drupal\Core\Entity\EntityInterface.
 * @param callable $label_callback
 *   A function that takes an object that implements EntityInterface and
 *   returns the appropriate text or markup for the label for that Entity.
 *
 * @return string
 *   Label for all the entities with appropriate delimiter(s) depending on number.
 */
function sw_get_entity_label_multiple(array $entities, $label_callback) {
  $text = '';
  $last = array_pop($entities);
  $last_label = $label_callback($last);
  $text = implode(', ', array_map($label_callback, $entities));
  if (!empty($text)) {
    $text .= " and $last_label";
  }
  else {
    $text = $last_label;
  }
  return $text;
}

/**
 * Returns the appropriate caption (if any) to use for a given media entity.
 *
 * @param integer $entity_id
 *   The ID of the entity we're considering.
 *
 * @return string
 *   The appropriate caption, or NULL if there is none.
 */
function sw_get_media_caption($entity_id) {
  $entity = Drupal\media\Entity\Media::load($entity_id);
  if (!empty($entity)) {
    $caption = '';
    $default_caption = $entity->get('field_default_caption')->value;
    $credits = $entity->get('field_credit')->referencedEntities();
    $provider = $entity->get('field_image_provider')->entity;
    if (!empty($default_caption)) {
      $caption = $default_caption;
    }
    if (!empty($credits)) {
      // If there's already a caption, add a space before credits.
      $caption .= empty($caption) ? '(' : ' (';
      $caption .= implode(', ', array_map('sw_plain_label', $credits));
    }
    if (!empty($provider)) {
      if (!empty($credits)) {
        // If there's already credits, separate the provider with '|'.
        $caption .= ' | ';
      }
      elseif (!empty($caption)) {
        // Otherwise, if there's a caption, we need a space.
        $caption .= ' (';
      }
      else {
        // Otherwise, the provider is the only caption, no space.
        $caption .= '(';
      }
      $caption .= $provider->label();
    }
    if (!empty($credits) || !empty($provider)) {
      $caption .= ')';
    }
    return $caption;
  }
}

/**
 * Implements hook_ENTITY_TYPE_embed_alter().
 *
 * Preserves 'data-entity-id' while embedding entities so our custom caption
 * filter can load the embedded entity when it needs it. Also sticks the value
 * of data-view-mode as a class on the container element.
 */
function sw_media_embed_alter(array &$build, EntityInterface $entity, array &$context) {
  $build['#attributes']['data-entity-id'] = $context['data-entity-id'];
  $build['#attributes']['class'][] = str_replace('_', '-', $context['data-view-mode']);
}

/**
 * Implements hook_block_view_alter().
 *
 * @param array $build
 * @param \Drupal\Core\Block\BlockPluginInterface $block
 */
function sw_block_view_alter(array &$build, BlockPluginInterface $block) {
  if ($block instanceof SWTodaysStoriesBlock) {
    $build['#configuration']['label'] = $block->label();
    $build['#cache']['max-age'] = 86400; // 1 day = 60 * 60 * 24
  }
}

/**
 * Implements hook_theme().
 */
function sw_theme() {
  return [
    'sw_mailerlite_subscribe_form' => [
      'variables' => ['form_type' => NULL],
    ],
  ];
}

/**
 * Prepares variables for MailerLite subscribe form.
 *
 * Default template: sw-mailerlite-subscribe-form.html.twig
 *
 * @param array $variables
 *   An associative array containing:
 *   - form_type: Either 'page' or 'block'.
 *
 */
function template_preprocess_sw_mailerlite_subscribe_form(&$variables) {
  $form_classes[] = 'ml-block-form';
  $form_classes[] = 'sw-mailerlite-form-' . $variables['form_type'];
  $variables['form_classes'] = 'class="' . implode(' ', $form_classes) . '"';
  if ($variables['form_type'] == 'page') {
    $variables['form_intro'] = t('SocialistWorker.org sends out e-mail alerts to let subscribers know about new articles that have been posted and point out special features on our site.');
  }
  else {
    $variables['form_intro'] = t('Get e-mail alerts from SocialistWorker.org');
  }
}

/**
 * Helper function to find the taxnomy term from a given URL argument.
 *
 * Uses a static cache to avoid doing lots of entity load on a story list.
 *
 * @param string $vocabulary
 *  The machine name of the vocabulary we expect to find the term in.
 * @param string $url_arg
 *  The portion of a URL that points to a specific term. Usually the same as the
 *  term name, but with spaces converted to '-' and all lower case.
 *
 * @return \Drupal\taxonomy\TermInterface
 *  A fully-loaded taxonomy term entity that matches, or NULL if not found.
 */
function sw_get_term_from_path($vocabulary, $url_arg) {
  static $terms = [];
  if (!isset($terms[$vocabulary][$url_arg])) {
    $values = [
      'vid' => $vocabulary,
      'name' => str_replace('-', ' ', $url_arg),
    ];
    $term_entities = \Drupal::entityManager()->getStorage('taxonomy_term')->loadByProperties($values);
    $terms[$vocabulary][$url_arg] = !empty($term_entities) ? reset($term_entities) : NULL;
  }
  return $terms[$vocabulary][$url_arg];
}

/**
 * @param \Drupal\node\NodeInterface $node
 *   The fully-loaded node entity that contains the series insert box.
 *
 * @return \Drupal\taxonomy\TermInterface
 *   A fully-loaded taxonomy term entity for the series, or NULL if there is none.
 */
function sw_get_series_term(NodeInterface $node) {
  $series_value = $node->get('field_series')->getValue();
  if (!empty($series_value[0])) {
    $series_terms = Term::loadMultiple($series_value[0]);
    if (!empty($series_terms)) {
      return reset($series_terms);
    }
  }
}

/**
 * Generate the render array for the automagic series insert box.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The fully-loaded node entity that contains the series insert box.
 *
 * @return array
 *   A render array for the insert box.
 *
 * @todo Maybe this whole thing should be converted into a twig template.
 */
function sw_insert_series_box(NodeInterface $node) {
  // The render array is dependent upon edits to the host node.
  $build['#cache']['tags'][] = 'node:' . $node->id();
  $series_term = sw_get_series_term($node);

  // If there's no series for this story, bail early.
  if (empty($series_term)) {
    // @todo: Should we log something to the watchdog about this? This is an
    // error condition.
    return $build;
  }

  // The render array is dependent upon edits to the series term.
  $build['#cache']['tags'][] = 'taxonomy_term:' . $series_term->id();
  $build += [
    '#prefix' => '<article class="node--type-insert-box series">',
    '#suffix' => '</article>',
    'header' => [
      '#prefix' => '<a href="' . sw_get_series_url($series_term)->toString() . '">',
      '#suffix' => '</a>',
      'label' => [
        // @todo: Should this be a more semantically accurate class name?
        '#prefix' => '<div class="story-label">',
        '#markup' => t('Series'),
        '#suffix' => '</div>',
      ],
      'title' => [
        '#prefix' => '<h2>',
        '#markup' => $series_term->getName(),
        '#suffix' => '</h2>',
      ],
    ],
  ];
  $description = $series_term->getDescription();
  if (!empty($description)) {
    $build['description'] = [
      '#prefix' => '<p class="description">',
      '#markup' => $description,
      '#suffix' => '</p>',
    ];
  }
  $story_list_length = $series_term->get('field_series_insert_list_length')->value;
  if (!empty($story_list_length)) {
    $show_story_label = $series_term->get('field_show_story_labels')->value;
    $items = [];
    foreach (sw_get_series_stories($series_term, $story_list_length) as $nid => $story) {
      $items[] = sw_get_story_render_array($story, $show_story_label);
    }
    $build['stories'] = [
      '#theme' => 'item_list',
      '#list_type' => 'ul',
      '#items' => $items,
      '#wrapper_attributes' => [
        'class' => 'story-list',
      ],
    ];
  }
  // Unless we're already showing all the articles as a story list, provide an
  // explicit link to the whole series page.
  if ($story_list_length != -1) {
    $build['all_link'] = [
      '#type' => 'link',
      '#title' => t('All articles in this series'),
      '#url' => sw_get_series_url($series_term),
      '#prefix' => '<p class="all-link">',
      '#suffix' => '</p>',
    ];
  }
  return $build;
}

/**
 * Returns a render array for a given story.
 *
 * @param array $story
 *   An array of story data, with keys 'nid' and 'title'.
 * @param boolean $show_story_label
 *   Boolean that controls if the render array should include a story label.
 *
 * @return array
 *   A valid render array to display the given story.
 *
 * @see sw_get_story_label()
 */
function sw_get_story_render_array(array $story, $show_story_label = FALSE) {
  // Use absolute URLs so that these sorts of links work fine in emails, RSS, etc.
  $node_url = new Url('entity.node.canonical', ['node' => $story['nid']], ['absolute' => TRUE]);
  $build = [
    '#prefix' => '<a class="story-link" href="' . $node_url->toString() . '">',
    '#suffix' => '</a>',
    // This render array is dependent upon edits to the story we're displaying.
    '#cache' => ['tags' => ['node:' . $story['nid']]],
  ];
  if ($show_story_label) {
    // @todo: If we denormalize the story_label into a separate field, we
    // don't need to incur the cost of all the full entity loads here.
    $node = \Drupal\node\Entity\Node::load($story['nid']);
    foreach (['authors', 'interviewees'] as $field_id) {
      sw_load_referenced_entities($node, $field_id, ['Drupal\node\Entity\Node', 'loadMultiple']);
    }
    $build['story_label'] = [
      '#markup' => sw_get_story_label($node, 'teaser'),
      '#prefix' => '<div class="story-label">',
      '#suffix' => '</div>',
    ];
  }
  $build['headline'] = [
    '#markup' => $story['title'],
    '#prefix' => '<h4 class="headline">',
    '#suffix' => '</h4>',
  ];
  return $build;
}

/**
 * Helper function to get the path to a series series list.
 *
 * @param \Drupal\taxonomy\TermInterface $series_term
 *   A fully loaded taxonomy entity representing the series.
 *
 * @return \Drupal\Core\Url
 *   The Url object for the link to the series story list page.
 */
function sw_get_series_url(TermInterface $series_term) {
  $path_arg = str_replace([' ', '?'], ['-', '%3F'], strtolower($series_term->getName()));
  return Url::fromUri('internal:/series/' . $path_arg);
}

/**
 * Build an array of stories belonging to a given series.
 *
 * Uses a static cache to avoid querying for the story list multiple times on
 * the same page load.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   The fully-loaded taxonomy term entity for the series.
 * @param integer $length
 *   Length of the story list. Use -1 for unlimited, 0 for no list, otherwise,
 *   the specific limit.
 *
 * @return array
 *   Array of stories from the series, in chronological order. Keys are node ID
 *   (nid). Values are nested arrays with 'nid' and 'title' keys.
 */
function sw_get_series_stories(TermInterface $term, $length = -1) {
  static $stories = [];
  if (empty($stories[$term->id()][$length])) {
    $query = \Drupal::database()->select('node_field_data', 'nfd')
      ->fields('nfd', ['nid', 'title']);
    $query->join('taxonomy_index', 'ti', 'nfd.nid = ti.nid');
    $query->condition('ti.tid', $term->id(), '=');
    $query->orderBy('nfd.created', 'ASC');
    if ($length != -1) {
      $query->range(0, $length);
    }
    $stories[$term->id()][$length] = $query->execute()->fetchAllAssoc('nid', PDO::FETCH_ASSOC);
  }
  return $stories[$term->id()][$length];
}

/**
 * Find the 'prev' and 'next' links for a given story within a series.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The fully-loaded node entity for the story.
 * @param \Drupal\taxonomy\TermInterface $series
 *   The fully-loaded taxonomy term entity for the series.
 *
 * @return array
 *   Array keyed with 'next' and 'prev', where values are render arrays for
 *   links to the appropriate stories, or NULL if there's no appropriate link.
 *   E.g. 'prev' will be NULL if we're on the first article in a series.
 */
function sw_get_series_navigation(NodeInterface $node, TermInterface $series) {
  $prev = $next = NULL;
  $stories = sw_get_series_stories($series);
  // We used to use each() for this, but that's now deprecated.
  // foreach() is the "safe" and recommended way, but we can't rely on it using
  // the internal array pointer, so tricks with next() or prev() aren't safe.
  // So, we fudge it with a flag, let foreach iterate, and we never care about
  // the internal array pointer.
  $break_on_next = FALSE;
  foreach ($stories as $story) {
    // If we already hit the current article and set the flag, foreach will have
    // just given us the next story and we should set that as our next link
    // before we break out of the loop.
    if ($break_on_next) {
      $next = $story;
      break;
    }
    // If we're on the current story, set a flag to know we want to break out of
    // the loop on the next iteration. If this is the last story in the series,
    // foreach will bail before we can set $next, which is exactly what we want.
    if ($story['nid'] == $node->id()) {
      $break_on_next = TRUE;
    }
    // Otherwise, remember this story as the "previous" link in case the next
    // article in the array is the story we're building navigation for.
    else {
      $prev = $story;
    }
  }
  return [
    'prev' => empty($prev) ? NULL : sw_get_story_render_array($prev),
    'next' => empty($next) ? NULL : sw_get_story_render_array($next),
  ];
}

/**
 * Find (and remember) the issue number taxonomy term of the current page (if any).
 *
 * @param \Drupal\views\ViewExecutable $view
 *   The ViewExecutable for the current page. We harvest the argument to load
 *   the term directly.
 *
 * @return \Drupal\taxonomy\TermInterface
 *   The full-loaded taxonomy_term entity for the current issue_number term.
 */
function sw_get_issue_term(ViewExecutable $view = NULL) {
  static $issue_term = NULL;
  if (empty($issue_term)) {
    if (!empty($view) && $view->id() == 'sw_issue_stories' && !empty($view->argument['tid']->argument)) {
      $issue_term = Term::load($view->argument['tid']->argument);
    }
  }
  return $issue_term;
}

/**
 * Implements hook_views_pre_render().
 *
 * Alters the issue story list view to hide stories that are already listed as
 * 'Top stories'. Since this runs relatively early in the page generation, it
 * also lets us initialize sw_get_issue_term() with the $view object so we can
 * load the term directly via tid from the view argument.
 *
 * @param \Drupal\views\ViewExecutable $view
 *   The ViewExecutable for the view we're about to render.
 *
 * @see sw_get_issue_term()
 */
function sw_views_pre_render(ViewExecutable $view) {
  if ($view->id() == 'sw_issue_stories') {
    // We only want to filter these stories out of the page display. We need
    // the full list for the entity_reference display.
    if ($view->getDisplay()->getPluginId() == 'page') {
      $issue_term = sw_get_issue_term($view);
      // If field_issue_top_stories is defined, remove them from the view list.
      $top_stories = $issue_term->get('field_issue_top_stories')->getValue();
      if (!empty($top_stories)) {
        $top_story_nids = [];
        foreach ($top_stories as $top_story) {
          if (!empty($top_story['target_id'])) {
            $top_story_nids[$top_story['target_id']] = TRUE;
          }
        }
        foreach ($view->result as $index => $result) {
          if (!empty($top_story_nids[$result->nid])) {
            unset($view->result[$index]);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_cron().
 *
 * Handles delayed draft-to-live.
 */
function sw_cron() {
  $state_keys = ['sw_front_page_target_draft', 'sw_front_page_request_uid'];
  $values = \Drupal::state()->getMultiple($state_keys);

  // Anytime cron is running when the hour is between 0 (midnight) and 3am, if
  // there's a pending draft-to-live, run it.
  if (!empty($values['sw_front_page_target_draft']) && date('G') < 3) {

    // To ensure draft-to-live runs as the user who submitted the form, we
    // need to safely impersonate them here. This way, all node access checks
    // will do the right things, even when cron is being triggered anonymously.
    $user = User::load($values['sw_front_page_request_uid']);
    if (!empty($user)) {
      user_login_finalize($user);

      $draft_to_live = new DraftToLive($values['sw_front_page_target_draft'], $values['sw_front_page_request_uid']);
      $draft_to_live->execute(FALSE); // Don't render messages to the screen.

      \Drupal::state()->deleteMultiple($state_keys);

      // Return to user 0 (anonymous)
      $user = User::load(0);
      user_login_finalize($user);
    }
  }
}

/**
 * Build a query object to find stories associated with the given taxonomy terms.
 *
 * @param array $tids
 *   Array of numeric term IDs (TIDs) to search for.
 * @param array $exclude_nids
 *   Optional array of numeric nods IDs (NIDs) to exclude from the search.
 * @param integer $limit
 *   Optional maximum number of stories to return in the results.
 * @param integer $weight_max
 *   Optional limit on the story weight. If defined, only stories lighter (more
 *   important) than this maximum will be returned.
 *
 * @return \Drupal\Core\Database\Query\SelectInterface
 *   A Select query object for the story query.
 */
function sw_story_taxonomy_query(array $tids, $exclude_nids = [], $limit = 0, $weight_max = NULL) {
  $query = \Drupal::database()
    ->select('node_field_data', 'nfd')
    ->fields('nfd', ['nid']);
  $query->addExpression("DATE_FORMAT((DATE_ADD('19700101', INTERVAL nfd.created SECOND) + INTERVAL -18000 SECOND), '%Y%m%d')", 'created_day');
  $query->join('taxonomy_index', 'ti', 'nfd.nid = ti.nid');
  $query->join('node__field_story_weight', 'nfsw', 'nfd.nid = nfsw.entity_id AND nfd.vid = nfsw.revision_id');
  $query->condition('nfd.status', 1, '=')
    ->condition('nfd.type', 'story', '=')
    ->condition('ti.tid', $tids, 'IN');

  if (!empty($exclude_nids)) {
    $query->condition('nfd.nid', $exclude_nids, 'NOT IN');
  }
  if (isset($weight_max)) {
    // Limit the list to stories more important (lighter) than a given weight.
    $query->condition('nfsw.field_story_weight_value', $weight_max, '<=');
  }

  $query->orderBy('created_day', 'DESC');
  $query->orderBy('nfsw.field_story_weight_value', 'ASC');

  if (!empty($limit)) {
    $query->range(0, $limit);
  }

  return $query;
}
