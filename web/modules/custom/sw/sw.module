<?php

use Drupal\Core\Block\BlockPluginInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityManagerInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Link;
use Drupal\Core\Render\Element;
use Drupal\Core\Routing;

use Drupal\media\Entity\Media;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\Entity\Term;

use Drupal\sw\Plugin\Block\SWTodaysStoriesBlock;

const SW_SECTION_EDITORIALS_TID = 11;
const SW_SECTION_READERS_VIEWS_TID = 9;
const SW_SECTION_OBRERO_SOCIALISTA_TID = 17255;

const SW_INSERT_BOX_TYPE_COLUMNIST_TID = 262;
const SW_INSERT_BOX_TYPE_REVIEW_TID = 265;
const SW_INSERT_BOX_TYPE_SERIES_TID = 267;

const SW_STORY_TYPE_CUSTOM_TID = 391;
const SW_STORY_TYPE_INTERVIEW_TID = 393;
const SW_STORY_TYPE_OBITUARY_TID = 4556;
const SW_STORY_TYPE_ROUNDTABLE_TID = 2922;

const SW_TOPIC_NONE_TID = 412;

/**
 * Implements hook_form_FORM_ID_alter() for 'taxonomy_overview_terms'.
 *
 * Inject a 'TID' column into the term overview page.
 */
function sw_form_taxonomy_overview_terms_alter(&$form, FormStateInterface $form_state) {
  $form['terms']['#header'][] = t('TID');
  foreach (Element::children($form['terms']) as $id) {
    $form['terms'][$id]['tid_display'] = [
      '#type' => 'markup',
      '#markup' => $form['terms'][$id]['#term']->id(),
    ];
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'views_bulk_operations_configure_action'.
 */
function sw_form_views_bulk_operations_configure_action_alter(&$form, FormStateInterface $form_state) {
  $form_data = $form_state->get('views_bulk_operations');
  if (!empty($form_data['view_id']) && $form_data['view_id'] == 'sw_admin_bulk_edit_story') {
    foreach (['langcode', 'revision_log'] as $key) {
      $form['node']['story'][$key]['#access'] = FALSE;
      $form['node']['story']['_field_selector'][$key]['#access'] = FALSE;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'media_image_add_form'.
 */
function sw_form_media_image_add_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _sw_form_media_image_form_alter($form, $form_state, $form_id);
}

/**
 * Implements hook_form_FORM_ID_alter() for 'media_image_edit_form'.
 */
function sw_form_media_image_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _sw_form_media_image_form_alter($form, $form_state, $form_id);
}

/**
 * Helper function for shared altering for media image forms (add and edit).
 */
function _sw_form_media_image_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['field_original_image']['#states'] = [
    'visible' => [
      ':input[name="field_image_crop_type"]' => ['value' => 1],
    ],
  ];
}

/**
 * Implements hook_form_FORM_ID_alter() for 'node_form'.
 *
 * Improves the UI for story node forms via #states.
 */
function sw_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $node = $form_state->getFormObject()->getEntity();
  switch ($node->bundle()) {
    case 'story':
      sw_story_node_form_alter($form, $form_state, $form_id);
      break;

    case 'insert_box':
      sw_insert_box_node_form_alter($form, $form_state, $form_id);
      break;

  }
}

/**
 * Helper for hook_form_FORM_ID_alter() for story nodes.
 *
 * Improves the UI by only conditionally showing relevant fields based on the
 * values of other fields via #states.
 */
function sw_story_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['field_kicker']['#states'] = [
    'visible' => [
      ':input[name="field_kicker[0][value]"]' => ['filled' => TRUE],
    ],
  ];
  $form['field_interviewees']['#states'] = [
    'visible' => [
      ':input[name="field_story_type"]' => [
        ['value' => SW_STORY_TYPE_INTERVIEW_TID],
        ['value' => SW_STORY_TYPE_OBITUARY_TID],
      ],
    ],
  ];
  $form['field_story_label']['#states'] = [
    'visible' => [
      ':input[name="field_story_type"]' => ['value' => SW_STORY_TYPE_CUSTOM_TID],
    ],
  ];

  // Set #pre_render to hide filter format guidelines on all text areas.
  foreach (['field_teaser', 'field_body', 'field_introduction', 'field_body_introduction'] as $field) {
    $form[$field]['#pre_render'][] = 'sw_hide_format_guidelines_form_pre_render';
  }
}

/**
 * #pre_render callback to hide all the text area filter format guidelines.
 */
function sw_hide_format_guidelines_form_pre_render(array $element) {
  if (!empty($element['widget'][0]['format']['guidelines'])) {
    $element['widget'][0]['format']['guidelines']['#access'] = FALSE;
  }
  return $element;
}

/**
 * Helper for hook_form_FORM_ID_alter() for insert_box nodes.
 *
 * Improves the UI by only conditionally showing relevant fields based on the
 * values of other fields via #states.
 */
function sw_insert_box_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['title']['widget'][0]['value']['#description'] = t('This field is just for administrators to give insert boxes more meaningful names. For example, this is useful when browsing for the box to insert in a given story.');
  $form['field_header_text']['#states'] = [
    'visible' => [
      ':input[name="field_insert_type"]' => [
        ['value' => SW_INSERT_BOX_TYPE_COLUMNIST_TID],
        ['value' => SW_INSERT_BOX_TYPE_REVIEW_TID],
        ['value' => SW_INSERT_BOX_TYPE_SERIES_TID],
      ],
    ],
  ];
  $form['field_insert_body']['#pre_render'][] = 'sw_hide_format_guidelines_form_pre_render';
}


/**
 * Implements hook_preprocess_HOOK() for taxonomy terms.
 */
function sw_preprocess_taxonomy_term(&$variables) {
  // If we're on one of our term-driven story lists, tell the twig template to
  // think we're a full-page view so we don't print a duplicate label + link.
  $view_id = \Drupal::routeMatch()->getParameter('view_id');
  if (!empty($view_id)) {
    switch ($view_id) {
      case 'sw_section_stories':
      case 'sw_series_stories':
      case 'sw_topic_stories':
        $variables['page'] = TRUE;
        break;

    }
  }
}

/**
 * Implements hook_preprocess_HOOK() for nodes.
 *
 * For now, we're only processing stories, but that'll change. Instead of
 * stuffing everything into a giant function, call bundle-specific functions.
 */
function sw_preprocess_node(&$variables) {
  switch ($variables['node']->getType()) {
    case 'story':
      sw_preprocess_node_story($variables);
      break;

    case 'insert_box':
      sw_preprocess_node_insert_box($variables);
      break;
  }
}

/**
 * Preprocess function for story nodes.
 *
 * Inject the correct story_label based on the complex logic.
 *
 * On full view mode, also rewrites introduction and body_introduction to
 * replace %author and %interviewee.
 *
 * Handles the display-friendly version of field_contributors (sorts
 * alphabetically based on last name, adds appropriate delimiters and puts it
 * all on a single line.).
 *
 * For the teaser-conditional-image view mode, hides images on stories that
 * don't have weight -8 or lighter.
 */
function sw_preprocess_node_story(&$variables) {
  // For any view mode, we're going to need to load the authors (and
  // interviewee) if any. For teasers, we'll need them for the story label.
  // For full view, we'll also need them to rewrite '%author' (and perhaps
  // %interviewee) in the introduction. So, we load all these target entities
  // once, and stash them into the $node object for re-use.
  foreach (['authors', 'interviewees'] as $field_id) {
    sw_load_referenced_entities($variables['node'], $field_id, ['Drupal\node\Entity\Node', 'loadMultiple']);
  }

  $variables['story_label'] = sw_get_story_label($variables['node'], $variables['view_mode']);

  if ($variables['view_mode'] == 'full') {
    if (!empty($variables['node']->sw_authors)) {
      $placeholders['%author'] = sw_get_entity_label_multiple($variables['node']->sw_authors, 'sw_author_label');
    }
    if (!empty($variables['node']->sw_interviewees)) {
      $placeholders['%interviewee'] = sw_get_entity_label_multiple($variables['node']->sw_interviewees, 'sw_subject_label');
    }
    if (!empty($placeholders)) {
      foreach (['field_introduction', 'field_body_introduction'] as $intro_field) {
        if (!empty($variables['content'][$intro_field][0]['#text'])) {
          $variables['content'][$intro_field][0]['#text'] = strtr($variables['content'][$intro_field][0]['#text'], $placeholders);
        }
      }
    }
    sw_load_referenced_entities($variables['node'], 'contributors', ['Drupal\taxonomy\Entity\Term', 'loadMultiple']);
    if (!empty($variables['node']->sw_contributors)) {
      uasort($variables['node']->sw_contributors, 'sw_contributor_sort');
      $variables['content']['contributors'] = [
        '#prefix' => '<div class="contributors">',
        '#markup' => sw_get_entity_label_multiple($variables['node']->sw_contributors, 'sw_plain_label') . t(' contributed to this article.'),
        '#suffix' => '</div>',
        '#weight' => '100',
      ];
    }
  }

  if ($variables['view_mode'] == 'teaser_conditional_image') {
    // Hide main_image based on story_weight.
    $weight = $variables['node']->get('field_story_weight')->getValue();
    $main_image = $variables['node']->get('field_main_image')->getValue();
    // -7 and heavier is "greater than" in the math world. This logic seems
    // backwards, but it's right given the inverted meaning of weights.
    // However, even for important stories (-8 and "above"), don't set the
    // "...-with-image" class if there's no value for field_main_image.
    if ($weight[0]['value'] > -8 || empty($main_image)) {
      unset($variables['content']['field_main_image']);
      $variables['attributes']['class'][] = 'teaser-conditional-no-image';
    }
    else {
      $variables['attributes']['class'][] = 'teaser-conditional-with-image';
    }

    // See if we're on a story list where the story labels don't make sense.
    // Since the story label is conditional on the page we're viewing, the
    // resulting render array can only be cached per route/page.
    $variables['#cache']['contexts'][] = 'route';
    $route_parameters = \Drupal::routeMatch()->getParameters();
    if ($route_parameters) {
      $view_id = $route_parameters->get('view_id');
      if (!empty($view_id) && $view_id == 'sw_section_stories') {
        $arg_0 = $route_parameters->get('arg_0');
        if (!empty($arg_0)) {
          switch (strtolower($arg_0)) {
            case 'editorials':
            case "readers'-views":
            case 'obrero-socialista':
              // @todo It'd be better not to compute these in the first place...
              unset($variables['story_label']);
              break;
          }
        }
      }
      elseif (!empty($view_id) && $view_id == 'sw_recent') {
        unset($variables['date']);
      }
      elseif (!empty($view_id) && $view_id == 'sw_series_stories') {
        // Sort of ugly. It's not easy to get the currently active View object
        // to inquire directly about the taxonomy argument it's using. Call a
        // helper method to find the term given a URL argument.
        $arg_0 = $route_parameters->get('arg_0');
        $term = sw_get_term_from_path('series', $arg_0);
        if (!empty($term)) {
          // Since this render array is dependent upon fields on the taxonomy
          // term, add it to the #cache tags.
          $variables['#cache']['tags'][] = 'taxonomy_term:' . $term->id();
          // If the term doesn't want story labels, hide them.
          if (empty($term->get('field_show_story_labels')->value)) {
            unset($variables['story_label']);
          }
        }
      }
      else {
        $node = $route_parameters->get('node');
        if (!empty($node) && $node->getType() == 'person') {
          if ($variables['story_label'] == $node->getTitle()) {
            unset($variables['story_label']);
          }
        }
      }
    }
  }

}

/**
 * Preprocess function for insert_box nodes.
 *
 * Replace the title (which is only for admins) with the display-appropriate title.
 * The display title is based on insert type, and optionally header_text.
 *
 */
function sw_preprocess_node_insert_box(&$variables) {
  $insert_type = $variables['node']->get('field_insert_type')->entity;
  $header_text = $variables['node']->get('field_header_text')->value;
  $insert_title = $insert_type->label();
  switch ($insert_type->id()) {
    case SW_INSERT_BOX_TYPE_COLUMNIST_TID:
    case SW_INSERT_BOX_TYPE_REVIEW_TID:
    case SW_INSERT_BOX_TYPE_SERIES_TID:
      if (!empty($header_text)) {
        $insert_title .= ': ' . $header_text;
      }
      break;
  }
  $variables['label'] = $insert_title;
}

/**
 * Load entities pointed to via an entity_reference field into the host entity.
 *
 * The array of loaded entities is stuffed into the host entity at the 'sw_'
 * namespace, and will be keyed by entity IDs (as returned by whatever version
 * of Entity::loadMultiple() is passed in).
 *
 * @param EntityInterface $entity
 *   The host entity with an entity_reference field that points to the
 *   entities to load.
 * @param string $field_id
 *   Identifier for the entity_reference field to use (without the 'field_' prefix).
 * @param callable $load_multiple_function
 *   A callable static method that will load multiple entities given an array of IDs.
 *   For example, "['Drupal\taxonomy\Entity\Term', 'loadMultiple']" to load terms or
 *   "['Drupal\node\Entity\Node', 'loadMultiple']" to load nodes.
 *
 * @see \Drupal\Core\Entity\Entity::loadMultiple()
 */
function sw_load_referenced_entities(EntityInterface $entity, $field_id, $load_multiple_function) {
  $targets = $entity->get('field_' . $field_id)->getValue();
  if (!empty($targets)) {
    foreach ($targets as $target) {
      $target_ids[] = $target['target_id'];
    }
    $entity->{'sw_' . $field_id} = $load_multiple_function($target_ids);
  }
}

function sw_contributor_sort($a, $b) {
  $a_name_parts = explode(' ', $a->label());
  $b_name_parts = explode(' ', $b->label());
  return strcmp(array_pop($a_name_parts), array_pop($b_name_parts));
}

/**
 * Label callback to return the plain entity label.
 */
function sw_plain_label(EntityInterface $entity) {
  return $entity->label();
};

/**
 * Label callback that wraps the entity label with author-specific markup.
 */
function sw_author_label(EntityInterface $entity) {
  return '<span class="sw-author">' . $entity->toLink()->toString() . '</span>';
};

/**
 * Label callback that wraps the entity label with subject-specific markup.
 *
 * Used for interviewee, obituary, etc.
 */
function sw_subject_label(EntityInterface $entity) {
  return '<span class="sw-subject">' . $entity->toLink()->toString() . '</span>';
};

/**
 * Generate the appropriate story label for a given story.
 *
 *  Pseudocode for the logic is as follows:
 *  if (section exists && section != ‘Movement News’) {
 *    $story_label = $section_name;
 *  }
 *  elseif (story type is interview || obituary ) {
 *    Story label = “$story_type: $interviewees” // (not the $authors)
 *  }
 *  elseif (story type is roundtable or custom) {
 *    Story label = the story type
 *  }
 *  elseif (story has authors ) {
 *    Story label = $author(s)
 *  }
 *  else {
 *    // no story label
 *  }
 *
 * @param \Drupal\node\NodeInterface $node
 *   A story node entity to generate the story label for.
 *
 * @param string $view_mode
 *   The view mode we're displaying the story with.
 *
 * @return string
 *   The story label (basically, the "byline") for the story.
 */
function sw_get_story_label(NodeInterface $node, $view_mode) {
  $story_label = '';

  $use_markup = $view_mode === 'full';

  $section = $node->get('field_section')->getValue();
  $story_type = $node->get('field_story_type')->getValue();

  if (!empty($section[0]['target_id'])) {
    switch ($section[0]['target_id']) {
      case SW_SECTION_EDITORIALS_TID:
        $story_label = t('Editorial');
        break;

      case SW_SECTION_READERS_VIEWS_TID:
        $story_label = t("Readers' View");
        break;

      case SW_SECTION_OBRERO_SOCIALISTA_TID:
        $story_label = t('Obrero Socialista');
        break;
    }
  }

  if (empty($story_label) && !empty($story_type[0]['target_id'])) {
    switch ($story_type[0]['target_id']) {
      case SW_STORY_TYPE_INTERVIEW_TID:
        $story_label = t('Interview');
        $target_field = 'sw_interviewees';
        break;

      case SW_STORY_TYPE_OBITUARY_TID:
        $story_label = t('Obituary');
        $target_field = 'sw_interviewees';
        break;

      case SW_STORY_TYPE_ROUNDTABLE_TID:
        $story_label = t('Roundtable');
        break;

      case SW_STORY_TYPE_CUSTOM_TID:
        $story_label = $node->get('field_story_label')->value;
        break;
    }
  }

  // Some stories are set as 'Interview' or 'Obituary' that don't define a
  // subject person. We have to handle that. If there are subject(s) defined,
  // add ': ' to the label before their name(s).
  if (!empty($target_field) && $target_field == 'sw_interviewees') {
    if (empty($node->sw_interviewees)) {
      $target_field = '';
    }
    else {
      $story_label .= ': '; 
      $label_func = $use_markup ? 'sw_subject_label' : 'sw_plain_label';
    }
  }

  // Nothing special from section or story type, use the author(s) (if any).
  if (empty($story_label) && !empty($node->sw_authors)) {
    $target_field = 'sw_authors';
    $label_func = $use_markup ? 'sw_author_label' : 'sw_plain_label';
  }

  if (!empty($target_field)) {
    $story_label .= sw_get_entity_label_multiple($node->{$target_field}, $label_func);
  }

  // If all else fails, provide a fallback since we never want an empty story label.
  if (empty($story_label)) {
    $story_label = t('Report');
  }
  
  return $story_label;
}

/**
 * Returns an appropriate label given an array of entities.
 *
 * If there's only 1 entity, return the label.
 * If 2, use "LabelA and LabelB".
 * If 3 or more "Label1, ... LabelN-1 and LabelN".
 *
 * @param array $entities
 *   An array of objects that implement \Drupal\Core\Entity\EntityInterface.
 * @param callable $label_callback
 *   A function that takes an object that implements EntityInterface and
 *   returns the appropriate text or markup for the label for that Entity.
 *
 * @return string
 *   Label for all the entities with appropriate delimiter(s) depending on number.
 */
function sw_get_entity_label_multiple(array $entities, $label_callback) {
  $text = '';
  $last = array_pop($entities);
  $last_label = $label_callback($last);
  $text = implode(', ', array_map($label_callback, $entities));
  if (!empty($text)) {
    $text .= " and $last_label";
  }
  else {
    $text = $last_label;
  }
  return $text;
}

/**
 * Returns the appropriate caption (if any) to use for a given media entity.
 *
 * @param integer $entity_id
 *   The ID of the entity we're considering.
 *
 * @return string
 *   The appropriate caption, or NULL if there is none.
 */
function sw_get_media_caption($entity_id) {
  $entity = Drupal\media\Entity\Media::load($entity_id);
  if (!empty($entity)) {
    $caption = '';
    $default_caption = $entity->get('field_default_caption')->value;
    $credits = $entity->get('field_credit')->referencedEntities();
    $provider = $entity->get('field_image_provider')->entity;
    if (!empty($default_caption)) {
      $caption = $default_caption;
    }
    if (!empty($credits)) {
      // If there's already a caption, add a space before credits.
      $caption .= empty($caption) ? '(' : ' (';
      $caption .= implode(', ', array_map('sw_plain_label', $credits));
    }
    if (!empty($provider)) {
      if (!empty($credits)) {
        // If there's already credits, separate the provider with '|'.
        $caption .= ' | ';
      }
      elseif (!empty($caption)) {
        // Otherwise, if there's a caption, we need a space.
        $caption .= ' (';
      }
      else {
        // Otherwise, the provider is the only caption, no space.
        $caption .= '(';
      }
      $caption .= $provider->label();
    }
    if (!empty($credits) || !empty($provider)) {
      $caption .= ')';
    }
    return $caption;
  }
}

/**
 * Implements hook_ENTITY_TYPE_embed_alter().
 *
 * Preserves 'data-entity-id' while embedding entities so our custom caption
 * filter can load the embedded entity when it needs it. Also sticks the value
 * of data-view-mode as a class on the container element.
 */
function sw_media_embed_alter(array &$build, EntityInterface $entity, array &$context) {
  $build['#attributes']['data-entity-id'] = $context['data-entity-id'];
  $build['#attributes']['class'][] = str_replace('_', '-', $context['data-view-mode']);
}

/**
 * Implements hook_block_view_alter().
 *
 * @param array $build
 * @param \Drupal\Core\Block\BlockPluginInterface $block
 */
function sw_block_view_alter(array &$build, BlockPluginInterface $block) {
  if ($block instanceof SWTodaysStoriesBlock) {
    $build['#configuration']['label'] = $block->label();
    $build['#cache']['max-age'] = 86400; // 1 day = 60 * 60 * 24
  }
}

/**
 * Implements hook_theme().
 */
function sw_theme() {
  return [
    'sw_mailerlite_subscribe_form' => [
      'variables' => ['form_type' => NULL],
    ],
  ];
}

/**
 * Prepares variables for MailerLite subscribe form.
 *
 * Default template: sw-mailerlite-subscribe-form.html.twig
 *
 * @param array $variables
 *   An associative array containing:
 *   - form_type: Either 'page' or 'block'.
 *
 */
function template_preprocess_sw_mailerlite_subscribe_form(&$variables) {
  $form_classes[] = 'ml-block-form';
  $form_classes[] = 'sw-mailerlite-form-' . $variables['form_type'];
  $variables['form_classes'] = 'class="' . implode(' ', $form_classes) . '"';
  if ($variables['form_type'] == 'page') {
    $variables['form_intro'] = t('SocialistWorker.org sends out e-mail alerts to let subscribers know about new articles that have been posted and point out special features on our site.');
  }
  else {
    $variables['form_intro'] = t('Get e-mail alerts from SocialistWorker.org');
  }
}

/**
 * Helper function to find the taxnomy term from a given URL argument.
 *
 * Uses a static cache to avoid doing lots of entity load on a story list.
 *
 * @param string $vocabulary
 *  The machine name of the vocabulary we expect to find the term in.
 * @param string $url_arg
 *  The portion of a URL that points to a specific term. Usually the same as the
 *  term name, but with spaces converted to '-' and all lower case.
 *
 * @return \Drupal\taxonomy\TermInterface
 *  A fully-loaded taxonomy term entity that matches, or NULL if not found.
 */
function sw_get_term_from_path($vocabulary, $url_arg) {
  static $terms = [];
  if (!isset($terms[$vocabulary][$url_arg])) {
    $values = [
      'vid' => $vocabulary,
      'name' => str_replace('-', ' ', $url_arg),
    ];
    $term_entities = \Drupal::entityManager()->getStorage('taxonomy_term')->loadByProperties($values);
    $terms[$vocabulary][$url_arg] = !empty($term_entities) ? reset($term_entities) : NULL;
  }
  return $terms[$vocabulary][$url_arg];
}
