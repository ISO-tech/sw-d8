<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\media\Entity\Media;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\Entity\Term;

const SW_SECTION_EDITORIALS_TID = 11;
const SW_SECTION_READERS_VIEWS_TID = 9;
const SW_SECTION_OBRERO_SOCIALISTA_TID = 17255;

const SW_INSERT_BOX_TYPE_COLUMNIST_TID = 262;
const SW_INSERT_BOX_TYPE_REVIEW_TID = 265;
const SW_INSERT_BOX_TYPE_SERIES_TID = 267;

const SW_STORY_TYPE_CUSTOM_TID = 391;
const SW_STORY_TYPE_INTERVIEW_TID = 393;
const SW_STORY_TYPE_OBITUARY_TID = 4556;
const SW_STORY_TYPE_ROUNDTABLE_TID = 2922;

/**
 * Implements hook_form_FORM_ID_alter() for 'media_image_add_form'.
 */
function sw_form_media_image_add_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _sw_form_media_image_form_alter($form, $form_state, $form_id);
}

/**
 * Implements hook_form_FORM_ID_alter() for 'media_image_edit_form'.
 */
function sw_form_media_image_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _sw_form_media_image_form_alter($form, $form_state, $form_id);
}

/**
 * Helper function for shared altering for media image forms (add and edit).
 */
function _sw_form_media_image_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['field_original_image']['#states'] = [
    'visible' => [
      ':input[name="field_image_crop_type"]' => ['value' => 1],
    ],
  ];
}

/**
 * Implements hook_form_FORM_ID_alter() for 'node_form'.
 *
 * Improves the UI for story node forms via #states.
 */
function sw_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $node = $form_state->getFormObject()->getEntity();
  switch ($node->bundle()) {
    case 'story':
      sw_story_node_form_alter($form, $form_state, $form_id);
      break;

    case 'insert_box':
      sw_insert_box_node_form_alter($form, $form_state, $form_id);
      break;

  }
}

/**
 * Helper for hook_form_FORM_ID_alter() for story nodes.
 *
 * Improves the UI by only conditionally showing relevant fields based on the
 * values of other fields via #states.
 */
function sw_story_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['field_kicker']['#states'] = [
    'visible' => [
      ':input[name="field_kicker[0][value]"]' => ['filled' => TRUE],
    ],
  ];
  $form['field_interviewees']['#states'] = [
    'visible' => [
      ':input[name="field_story_type"]' => [
        ['value' => SW_STORY_TYPE_INTERVIEW_TID],
        ['value' => SW_STORY_TYPE_OBITUARY_TID],
      ],
    ],
  ];
  $form['field_story_label']['#states'] = [
    'visible' => [
      ':input[name="field_story_type"]' => ['value' => SW_STORY_TYPE_CUSTOM_TID],
    ],
  ];

  // Set #pre_render to hide filter format guidelines on all text areas.
  foreach (['field_teaser', 'field_body', 'field_introduction', 'field_body_introduction'] as $field) {
    $form[$field]['#pre_render'][] = 'sw_hide_format_guidelines_form_pre_render';
  }
}

/**
 * #pre_render callback to hide all the text area filter format guidelines.
 */
function sw_hide_format_guidelines_form_pre_render(array $element) {
  if (!empty($element['widget'][0]['format']['guidelines'])) {
    $element['widget'][0]['format']['guidelines']['#access'] = FALSE;
  }
  return $element;
}

/**
 * Helper for hook_form_FORM_ID_alter() for insert_box nodes.
 *
 * Improves the UI by only conditionally showing relevant fields based on the
 * values of other fields via #states.
 */
function sw_insert_box_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['title']['widget'][0]['value']['#description'] = t('This field is just for administrators to give insert boxes more meaningful names. For example, this is useful when browsing for the box to insert in a given story.');
  $form['field_header_text']['#states'] = [
    'visible' => [
      ':input[name="field_insert_type"]' => [
        ['value' => SW_INSERT_BOX_TYPE_COLUMNIST_TID],
        ['value' => SW_INSERT_BOX_TYPE_REVIEW_TID],
        ['value' => SW_INSERT_BOX_TYPE_SERIES_TID],
      ],
    ],
  ];
  $form['field_insert_body']['#pre_render'][] = 'sw_hide_format_guidelines_form_pre_render';
}

/**
 * Implements hook_preprocess_HOOK() for nodes.
 *
 * For now, we're only processing stories, but that'll change. Instead of
 * stuffing everything into a giant function, call bundle-specific functions.
 */
function sw_preprocess_node(&$variables) {
  if ($variables['node']->getType() == 'story') {
    sw_preprocess_node_story($variables);
  }
}

/**
 * Preprocess function for story nodes.
 *
 * Inject the correct story_label based on the complex logic.
 *
 * On full view mode, also rewrites introduction and body_introduction to
 * replace %author and %interviewee
 */
function sw_preprocess_node_story(&$variables) {
  // For any view mode, we're going to need to load the authors (and
  // interviewee) if any. For teasers, we'll need them for the story label.
  // For full view, we'll also need them to rewrite '%author' (and perhaps
  // %interviewee) in the introduction. So, we load all these target entities
  // once, and stash them into the $node object for re-use.
  foreach (['authors', 'interviewees'] as $field_id) {
    sw_load_referenced_entities($variables['node'], $field_id, ['Drupal\node\Entity\Node', 'loadMultiple']);
  }

  $variables['story_label'] = sw_get_story_label($variables['node'], $variables['view_mode']);

  if ($variables['view_mode'] == 'full') {
    if (!empty($variables['node']->sw_authors)) {
      $placeholders['%author'] = sw_get_entity_label_multiple($variables['node']->sw_authors, 'sw_author_label');
    }
    if (!empty($variables['node']->sw_interviewees)) {
      $placeholders['%interviewee'] = sw_get_entity_label_multiple($variables['node']->sw_interviewees, 'sw_subject_label');
    }
    foreach (['field_introduction', 'field_body_introduction'] as $intro_field) {
      if (!empty($variables['content'][$intro_field][0]['#text'])) {
        $variables['content'][$intro_field][0]['#text'] = strtr($variables['content'][$intro_field][0]['#text'], $placeholders);
      }
    }
    sw_load_referenced_entities($variables['node'], 'contributors', ['Drupal\taxonomy\Entity\Term', 'loadMultiple']);
    if (!empty($variables['node']->sw_contributors)) {
      uasort($variables['node']->sw_contributors, 'sw_contributor_sort');
      $variables['content']['contributors'] = [
        '#prefix' => '<div class="contributors">',
        '#markup' => sw_get_entity_label_multiple($variables['node']->sw_contributors, 'sw_plain_label') . t(' contributed to this article.'),
        '#suffix' => '</div>',
        '#weight' => '100',
      ];
    }
  }

  // For teasers with conditional images, hide main_image based on story_weight.
  if ($variables['view_mode'] == 'teaser_conditional_image') {
    $weight = $variables['node']->get('field_story_weight')->getValue();
    // -7 and heavier is "greater than" in the math world. This logic seems
    // backwards, but it's right given the inverted meaning of weights.
    if ($weight[0]['value'] >= -8) {
      unset($variables['content']['field_main_image']);
    }
  }

}

/**
 * Load entities pointed to via an entity_reference field into the host entity.
 *
 * The array of loaded entities is stuffed into the host entity at the 'sw_'
 * namespace, and will be keyed by entity IDs (as returned by whatever version
 * of Entity::loadMultiple() is passed in).
 *
 * @param EntityInterface $entity
 *   The host entity with an entity_reference field that points to the
 *   entities to load.
 * @param string $field_id
 *   Identifier for the entity_reference field to use (without the 'field_' prefix).
 * @param callable $load_multiple_function
 *   A callable static method that will load multiple entities given an array of IDs.
 *   For example, "['Drupal\taxonomy\Entity\Term', 'loadMultiple']" to load terms or
 *   "['Drupal\node\Entity\Node', 'loadMultiple']" to load nodes.
 *
 * @see \Drupal\Core\Entity\Entity::loadMultiple()
 */
function sw_load_referenced_entities(EntityInterface $entity, $field_id, $load_multiple_function) {
  $targets = $entity->get('field_' . $field_id)->getValue();
  if (!empty($targets)) {
    foreach ($targets as $target) {
      $target_ids[] = $target['target_id'];
    }
    $entity->{'sw_' . $field_id} = $load_multiple_function($target_ids);
  }
}

function sw_contributor_sort($a, $b) {
  $a_name_parts = explode(' ', $a->label());
  $b_name_parts = explode(' ', $b->label());
  return strcmp(array_pop($a_name_parts), array_pop($b_name_parts));
}

/**
 * Label callback to return the plain entity label.
 */
function sw_plain_label(EntityInterface $entity) {
  return $entity->label();
};

/**
 * Label callback that wraps the entity label with author-specific markup.
 *
 * @todo This should return a link once we have something to link to.
 */
function sw_author_label(EntityInterface $entity) {
  return '<span class="sw-author">' . $entity->label() . '</span>';
};

/**
 * Label callback that wraps the entity label with subject-specific markup.
 *
 * Used for interviewee, obituary, etc.
 *
 * @todo This should return a link once we have something to link to.
 */
function sw_subject_label(EntityInterface $entity) {
  return '<span class="sw-subject">' . $entity->label() . '</span>';
};

/**
 * Generate the appropriate story label for a given story.
 *
 *  Pseudocode for the logic is as follows:
 *  if (section exists && section != ‘Movement News’) {
 *    $story_label = $section_name;
 *  }
 *  elseif (story type is interview || obituary ) {
 *    Story label = “$story_type: $interviewees” // (not the $authors)
 *  }
 *  elseif (story type is roundtable or custom) {
 *    Story label = the story type
 *  }
 *  elseif (story has authors ) {
 *    Story label = $author(s)
 *  }
 *  else {
 *    // no story label
 *  }
 *
 * @param \Drupal\node\NodeInterface $node
 *   A story node entity to generate the story label for.
 *
 * @param string $view_mode
 *   The view mode we're displaying the story with.
 *
 * @return string
 *   The story label (basically, the "byline") for the story.
 */
function sw_get_story_label(NodeInterface $node, $view_mode) {
  $story_label = '';

  $use_markup = $view_mode === 'full';

  $section = $node->get('field_section')->getValue();
  $story_type = $node->get('field_story_type')->getValue();

  if (!empty($section[0]['target_id'])) {
    switch ($section[0]['target_id']) {
      case SW_SECTION_EDITORIALS_TID:
        $story_label = t('Editorial');
        break;

      case SW_SECTION_READERS_VIEWS_TID:
        $story_label = t("Readers' View");
        break;

      case SW_SECTION_OBRERO_SOCIALISTA_TID:
        $story_label = t('Obrero Socialista');
        break;
    }
  }

  if (empty($story_label) && !empty($story_type[0]['target_id'])) {
    switch ($story_type[0]['target_id']) {
      case SW_STORY_TYPE_INTERVIEW_TID:
        $story_label = t('Interview: ');
        $target_field = 'sw_interviewees';
        $label_func = $use_markup ? 'sw_subject_label' : 'sw_plain_label';
        break;

      case SW_STORY_TYPE_OBITUARY_TID:
        $story_label = t('Obituary: ');
        $target_field = 'sw_interviewees';
        $label_func = $use_markup ? 'sw_subject_label' : 'sw_plain_label';
        break;

      case SW_STORY_TYPE_ROUNDTABLE_TID:
        $story_label = t('Roundtable');
        break;

      case SW_STORY_TYPE_CUSTOM_TID:
        $story_label = $node->get('field_story_label')->value;
        break;
    }
  }

  if (empty($story_label) && !empty($node->sw_authors)) {
    $target_field = 'sw_authors';
    $label_func = $use_markup ? 'sw_author_label' : 'sw_plain_label';
  }

  if (!empty($target_field)) {
    $story_label .= sw_get_entity_label_multiple($node->{$target_field}, $label_func);
  }

  // If all else fails, provide a fallback since we never want an empty story label.
  if (empty($story_label)) {
    $story_label = t('Report');
  }
  
  return $story_label;
}

/**
 * Returns an appropriate label given an array of entities.
 *
 * If there's only 1 entity, return the label.
 * If 2, use "LabelA and LabelB".
 * If 3 or more "Label1, ... LabelN-1 and LabelN".
 *
 * @param array $entities
 *   An array of objects that implement \Drupal\Core\Entity\EntityInterface.
 * @param callable $label_callback
 *   A function that takes an object that implements EntityInterface and
 *   returns the appropriate text or markup for the label for that Entity.
 *
 * @return string
 *   Label for all the entities with appropriate delimiter(s) depending on number.
 */
function sw_get_entity_label_multiple(array $entities, $label_callback) {
  $text = '';
  $last = array_pop($entities);
  $last_label = $label_callback($last);
  $text = implode(', ', array_map($label_callback, $entities));
  if (!empty($text)) {
    $text .= " and $last_label";
  }
  else {
    $text = $last_label;
  }
  return $text;
}

/**
 * Returns the appropriate caption (if any) to use for a given media entity.
 *
 * @param integer $entity_id
 *   The ID of the entity we're considering.
 *
 * @return string
 *   The appropriate caption, or NULL if there is none.
 */
function sw_get_media_caption($entity_id) {
  $entity = Drupal\media\Entity\Media::load($entity_id);
  if (!empty($entity)) {
    $caption = '';
    $default_caption = $entity->get('field_default_caption')->value;
    $credits = $entity->get('field_credit')->referencedEntities();
    $provider = $entity->get('field_image_provider')->entity;
    if (!empty($default_caption)) {
      $caption = $default_caption;
    }
    if (!empty($credits)) {
      // If there's already a caption, add a space before credits.
      $caption .= empty($caption) ? '(' : ' (';
      $caption .= implode(', ', array_map('sw_plain_label', $credits));
    }
    if (!empty($provider)) {
      if (!empty($credits)) {
        // If there's already credits, separate the provider with '|'.
        $caption .= ' | ';
      }
      elseif (!empty($caption)) {
        // Otherwise, if there's a caption, we need a space.
        $caption .= ' (';
      }
      else {
        // Otherwise, the provider is the only caption, no space.
        $caption .= '(';
      }
      $caption .= $provider->label();
    }
    if (!empty($credits) || !empty($provider)) {
      $caption .= ')';
    }
    return $caption;
  }
}

/**
 * Implements hook_ENTITY_TYPE_embed_alter().
 *
 * Preserves 'data-entity-id' while embedding entities so our custom caption
 * filter can load the embedded entity when it needs it.
 */
function sw_media_embed_alter(array &$build, EntityInterface $entity, array &$context) {
  $build['#attributes']['data-entity-id'] = $context['data-entity-id'];
}
