<?php

use Drupal\Core\Block\BlockPluginInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityManagerInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Link;
use Drupal\Core\Render\Element;
use Drupal\Core\Routing;
use Drupal\Core\Url;

use Drupal\file\FileInterface;
use Drupal\media\Entity\Media;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\Entity\Term;
use Drupal\taxonomy\TermInterface;
use Drupal\user\Entity\User;
use Drupal\views\ViewExecutable;

use Drupal\search_api\Query\QueryInterface;

use Drupal\sw\DraftToLive;
use Drupal\sw\Plugin\Block\SWTodaysStoriesBlock;

use Solarium\QueryType\Select\Query\Query;

// @todo: Create on SW 2.0 and finalize the nid.
const SW_ORG_AUTHOR_NID = 39262;

const SW_SECTION_EDITORIALS_TID = 11;
const SW_SECTION_READERS_VIEWS_TID = 9;
const SW_SECTION_OBRERO_SOCIALISTA_TID = 17255;
const SW_SECTION_LABOR_TID = 7;
const SW_SECTION_ACTIVIST_NEWS_TID = 8;

const SW_INSERT_BOX_TYPE_CUSTOM_TID = 256;
const SW_INSERT_BOX_TYPE_COLUMNIST_TID = 262;
const SW_INSERT_BOX_TYPE_REVIEW_TID = 265;
const SW_INSERT_BOX_TYPE_SERIES_TID = 267;

const SW_STORY_TYPE_CUSTOM_TID = 391;
const SW_STORY_TYPE_INTERVIEW_TID = 393;
const SW_STORY_TYPE_OBITUARY_TID = 4556;
const SW_STORY_TYPE_ROUNDTABLE_TID = 2922;

const SW_TOPIC_NONE_TID = 412;

/**
 * Implements hook_form_alter().
 *
 * Since there's no dedicated hook for it, we have to use the global form alter
 * check to see if we're dealing with an entity_browser form.
 */
function sw_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (substr($form_id, 0, 15) == 'entity_browser_') {
    sw_entity_browser_form_alter($form, $form_state, $form_id);
  }
}

/**
 * Form alter helper for all entity_browser forms.
 *
 * Moves the form actions to the tops of the browser view pages, so ideally you
 * don't have to scroll.
 */
function sw_entity_browser_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Only move the submit button to the top of browser views, not entity forms, etc.
  if (!empty($form['widget']['view'])) {
    $form['widget']['actions']['#weight'] = -10;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'taxonomy_overview_terms'.
 *
 * Inject a 'TID' column into the term overview page.
 */
function sw_form_taxonomy_overview_terms_alter(&$form, FormStateInterface $form_state) {
  $form['terms']['#header'][] = t('TID');
  foreach (Element::children($form['terms']) as $id) {
    $form['terms'][$id]['tid_display'] = [
      '#type' => 'markup',
      '#markup' => $form['terms'][$id]['#term']->id(),
    ];
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'views_bulk_operations_configure_action'.
 */
function sw_form_views_bulk_operations_configure_action_alter(&$form, FormStateInterface $form_state) {
  $form_data = $form_state->get('views_bulk_operations');
  if (!empty($form_data['view_id']) && $form_data['view_id'] == 'sw_admin_bulk_edit_story') {
    foreach (['langcode', 'revision_log'] as $key) {
      $form['node']['story'][$key]['#access'] = FALSE;
      $form['node']['story']['_field_selector'][$key]['#access'] = FALSE;
    }
    // And put the checkboxes for 'Main topic' and 'Secondary topic' at the top.
    foreach (['field_topic' => -100, 'field_secondary_topic' => -99] as $key => $weight) {
      $form['node']['story']['_field_selector'][$key]['#weight'] = $weight;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'views_exposed_form'.
 */
function sw_form_views_exposed_form_alter(&$form, FormStateInterface $form_state) {
  if (!empty($form['text'])) {
    $form['text']['#pre_render'] = [
      'sw_search_text_pre_render',
      // Oddly, we have to set this ourselves for the default value to appear.
      ['\Drupal\Core\Render\Element\Textfield', 'preRenderTextfield'],
    ];
  }
  $wrapped_field_sizes = [
    'nid' => 10,
    'title' => 20,
    'name' => 20,
    'book_caption' => 20,
    'first_name' => 20,
    'last_name' => 20,
    'full_name' => 20,
    'affiliation' => 20,
    'weight' => 4,
    'date' => 12,
  ];
  $sub_field_keys = ['value', 'min', 'max'];
  foreach ($wrapped_field_sizes as $field => $size) {
    $wrapper = $field . '_wrapper';
    foreach ($sub_field_keys as $sub_key) {
      if (!empty($form[$wrapper][$field][$sub_key])) {
        $form[$wrapper][$field][$sub_key]['#size'] = $size;
      }
    }
    if (!empty($form[$wrapper][$field])) {
      $form[$wrapper][$field]['#size'] = $size;
    }
  }
  $field_sizes = [
    'authors' => 15,
    'title' => 20,
  ];
  foreach ($field_sizes as $field => $size) {
    if (!empty($form[$field])) {
      $form[$field]['#size'] = $size;
    }
  }

  $view = $form_state->getStorage('view');
  switch ($view['view']->id()) {
    case 'media':
    case 'sw_media_entity_browser':
      $media_specific_fields = [
        'book' => ['book_caption'],
        'image' => ['image_crop', 'image_gallery', 'image_rights'],
      ];
      foreach ($media_specific_fields as $type_name => $type_elements) {
        foreach ($type_elements as $type_element) {
          if (!empty($form['type']) && !empty($form[$type_element])) {
            $form[$type_element]['#states'] = [
              'visible' => [
                ':input[name="type"]' => ['value' => $type_name],
              ],
            ];
          }
        }
      }
      break;
  }
}

/**
 * #pre_render callback to visually hide the label on the search text form element.
 */
function sw_search_text_pre_render(array $element) {
  $element['#title_display'] = 'visually-hidden';
  return $element;
}

/**
 * Implements hook_form_FORM_ID_alter() for 'media_image_add_form'.
 */
function sw_form_media_image_add_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _sw_form_media_image_form_alter($form, $form_state, $form_id);
}

/**
 * Implements hook_form_FORM_ID_alter() for 'media_image_edit_form'.
 */
function sw_form_media_image_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _sw_form_media_image_form_alter($form, $form_state, $form_id);
}

/**
 * Helper function for shared altering for media image forms (add and edit).
 */
function _sw_form_media_image_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['field_original_image']['#states'] = [
    'visible' => [
      ':input[name="field_image_crop_type"]' => ['value' => 1],
    ],
  ];
}

/**
 * Implements hook_form_FORM_ID_alter() for 'node_form'.
 *
 * Invokes bundle-specific methods to alter node forms.
 */
function sw_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $node = $form_state->getFormObject()->getEntity();
  switch ($node->bundle()) {
    case 'story':
      sw_story_node_form_alter($form, $form_state, $form_id);
      break;

    case 'insert_box':
      sw_insert_box_node_form_alter($form, $form_state, $form_id);
      break;

    case 'slices':
      sw_slices_node_form_alter($form, $form_state, $form_id);
      break;

  }
}

/**
 * Helper for hook_form_FORM_ID_alter() for story nodes.
 *
 * Improves the UI by only conditionally showing relevant fields based on the
 * values of other fields via #states, and hiding fields we don't want to see.
 *
 * Unassigns the 'created' field from the 'author' group so it can be placed.
 *
 * @see http://tasks.socialistworker.org/node/1096
 */
function sw_story_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (isset($form['created'])) {
    unset($form['created']['#group']);
  }
  $form['field_kicker']['#states'] = [
    'visible' => [
      ':input[name="field_kicker[0][value]"]' => ['filled' => TRUE],
    ],
  ];
  $form['field_interviewees']['#states'] = [
    'visible' => [
      ':input[name="field_story_type"]' => [
        ['value' => SW_STORY_TYPE_INTERVIEW_TID],
        ['value' => SW_STORY_TYPE_OBITUARY_TID],
      ],
    ],
  ];
  $form['field_story_label']['#states'] = [
    'visible' => [
      ':input[name="field_story_type"]' => ['value' => SW_STORY_TYPE_CUSTOM_TID],
    ],
  ];

  // Set #pre_render to hide filter format guidelines on all text areas.
  foreach (['field_teaser', 'field_body', 'field_introduction', 'field_body_introduction'] as $field) {
    $form[$field]['#pre_render'][] = 'sw_hide_format_guidelines_form_pre_render';
  }

  // If field_body_introduction has a value, expand the containing fieldset by default.
  if (!empty($form['field_body_introduction']['widget'][0]['#default_value'])) {
    $form['#fieldgroups']['group_body_introduction']->format_settings['open'] = TRUE;
  }
}

/**
 * #pre_render callback to hide all the text area filter format guidelines.
 */
function sw_hide_format_guidelines_form_pre_render(array $element) {
  if (!empty($element['widget'][0]['format']['guidelines'])) {
    $element['widget'][0]['format']['guidelines']['#access'] = FALSE;
  }
  return $element;
}

/**
 * Helper for hook_form_FORM_ID_alter() for insert_box nodes.
 *
 * Improves the UI by only conditionally showing relevant fields based on the
 * values of other fields via #states.
 */
function sw_insert_box_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['title']['widget'][0]['value']['#description'] = t('This field is just for administrators to give insert boxes more meaningful names. For example, this is useful when browsing for the box to insert in a given story.');
  $form['field_header_text']['#states'] = [
    'visible' => [
      ':input[name="field_insert_type"]' => [
        ['value' => SW_INSERT_BOX_TYPE_CUSTOM_TID],
        ['value' => SW_INSERT_BOX_TYPE_COLUMNIST_TID],
        ['value' => SW_INSERT_BOX_TYPE_REVIEW_TID],
        ['value' => SW_INSERT_BOX_TYPE_SERIES_TID],
      ],
    ],
  ];
  $form['field_insert_body']['#pre_render'][] = 'sw_hide_format_guidelines_form_pre_render';
}

/**
 * Helper for hook_form_FORM_ID_alter() for slices nodes.
 *
 * Adds a 'Save and continue' submit option.
 */
function sw_slices_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['actions']['continue'] = [
    '#type' => 'submit',
    '#value' => t('Save and continue'),
    '#button_type' => 'primary',
    '#submit' => [
      '::submitForm',  // Submit the entity form.
      '::save',        // Save it.
      'sw_slices_node_form_continue_submit',  // Redirect back to edit form.
    ],
  ];
  // Make the main 'Save' button 'secondary'.
  $form['actions']['submit']['#button_type'] = 'secondary';
}

/**
 * Submit callback for 'Save and continue' button on slices node forms.
 */
function sw_slices_node_form_continue_submit(array &$form, FormStateInterface $form_state) {
  // The entity form will already print a message, so all we have to do is redirect.
  $node = $form_state->getFormObject()->getEntity();
  $form_state->setRedirect('entity.node.edit_form', ['node' => $node->id()], []);
}

/**
 * Implements hook_preprocess_HOOK() for taxonomy terms.
 */
function sw_preprocess_taxonomy_term(&$variables) {
  // If we're on one of our term-driven story lists, tell the twig template to
  // think we're a full-page view so we don't print a duplicate label + link.
  $view_id = \Drupal::routeMatch()->getParameter('view_id');
  if (!empty($view_id)) {
    switch ($view_id) {
      case 'sw_section_stories':
      case 'sw_series_stories':
      case 'sw_topic_stories':
      case 'sw_issue_stories':
        $variables['page'] = TRUE;
        break;

    }
  }
  // Also render issue # terms for the front page (What We're Reading) as a
  // "full page" view so we don't add a broken link to the title as an h2.
  if ($variables['view_mode'] == 'front') {
    $variables['page'] = TRUE;
  }
}

/**
 * Implements hook_preprocess_HOOK() for nodes.
 *
 * Handles a few global things, then calls out to bundle-specific functions.
 */
function sw_preprocess_node(&$variables) {
  if ($variables['view_mode'] == 'search_result') {
    sw_preprocess_node_search_result($variables);
  }
  switch ($variables['node']->getType()) {
    case 'story':
      sw_preprocess_node_story($variables);
      break;

    case 'insert_box':
      sw_preprocess_node_insert_box($variables);
      break;

    case 'blog_critical_reading':
      $variables['story_label'] = t('From the Critical Reading blog');
      break;

    case 'blog_couldnt_make_it_up':
      $variables['story_label'] = t('From the Couldn’t Make It Up blog');
      break;

  }
}

/**
 * Preprocess function for story nodes.
 *
 * Inject the correct story_label based on the complex logic.
 *
 * On full view mode, RSS, and while forwarding, also rewrites introduction and
 * body_introduction to replace %author and %interviewee.
 *
 * Handles the display-friendly version of field_contributors (sorts
 * alphabetically based on last name, adds appropriate delimiters and puts it
 * all on a single line.).
 *
 */
function sw_preprocess_node_story(&$variables) {
  // For any view mode, we're going to need to load the authors (and
  // interviewee) if any. For teasers, we'll need them for the story label.
  // For full view, we'll also need them to rewrite '%author' (and perhaps
  // %interviewee) in the introduction. So, we load all these target entities
  // once, and stash them into the $node object for re-use.
  sw_load_story_people($variables['node']);

  $variables['story_label'] = sw_get_story_label($variables['node'], $variables['view_mode']);

  if (in_array($variables['view_mode'], ['full', 'forward', 'rss'])) {
    foreach (['field_introduction', 'field_body_introduction'] as $intro_field) {
      if (!empty($variables['content'][$intro_field][0]['#text'])) {
        $variables['content'][$intro_field][0]['#text'] = sw_replace_people_tokens($variables['node'], $variables['content'][$intro_field][0]['#text']);
      }
    }
    sw_load_referenced_entities($variables['node'], 'contributors');
    if (!empty($variables['node']->sw_contributors)) {
      uasort($variables['node']->sw_contributors, 'sw_contributor_sort');
      $variables['content']['contributors'] = [
        '#prefix' => '<div class="contributors">',
        '#markup' => sw_get_entity_label_multiple($variables['node']->sw_contributors, 'sw_plain_label') . t(' contributed to this article.'),
        '#suffix' => '</div>',
        '#weight' => '100',
      ];
    }
    $series = sw_get_series_term($variables['node']);
    if (!empty($series)) {
      $variables['series_navigation'] = sw_get_series_navigation($variables['node'], $series);
    }
  }

  // Now, anything view_mode-specific.
  switch ($variables['view_mode']) {
    case 'full':
      $path = $variables['node']->get('path')->getValue();
      $variables['email_url'] = Url::fromRoute('<front>', [], ['absolute' => TRUE])->toString() . 'email' . $path[0]['alias'];
      $variables['respond_url'] = Url::fromRoute('<front>', [], ['absolute' => TRUE])->toString() . 'respond' . $path[0]['alias'];
      break;

    case 'forward':
      $block_manager = \Drupal::service('plugin.manager.block');
      $plugin_block = $block_manager->createInstance('sw_further_reading_block', []);
      $variables['sw_further_reading_block'] = $plugin_block->buildFromNode($variables['node']);
      break;

    case 'teaser_image_large':
      $wide = $variables['node']->get('field_wide_image')->getValue();
      if (empty($wide)) {
        $mains = $variables['node']->get('field_main_image')->referencedEntities();
        $main = reset($mains);
        $main_fid = $main->get('field_media_image')->first()->getValue()['target_id'];
        if (!empty($main_fid)) {
          $image = \Drupal::entityTypeManager()->getStorage('file')->load($main_fid);
          // @todo: find this dynamically or make this configurable?
          $style_name = '825x624';
          $style = \Drupal::entityTypeManager()->getStorage('image_style')->load($style_name);
          $variables['content']['field_wide_image'][0] = [
            '#theme' => 'image',
            '#style_name' => $style_name,
            '#uri' => $style->buildUrl($image->getFileUri()),
          ];
          $variables['attributes']['class'][] = 'large-fallback';
        }
      }
      break;

    case 'teaser_conditional_image':
      sw_preprocess_node_story_teaser_conditional_image($variables);
      break;

  }
}

/**
 * Preprocess function for viewing story nodes via teaser-conditional-image.
 *
 * Hides images on stories that don't have weight -8 or lighter.  Handles
 * complex logic to conditionally hide the story label in various story lists.
 *
 * @param array $variables
 *   Reference to an array of template variables.
 */
function sw_preprocess_node_story_teaser_conditional_image(&$variables) {
  // Hide main_image based on story_weight.
  $weight = $variables['node']->get('field_story_weight')->getValue();
  $main_image = $variables['node']->get('field_main_image')->getValue();
  // -7 and heavier is "greater than" in the math world. This logic seems
  // backwards, but it's right given the inverted meaning of weights.
  // However, even for important stories (-8 and "above"), don't set the
  // "...-with-image" class if there's no value for field_main_image.
  if ($weight[0]['value'] > -8 || empty($main_image)) {
    unset($variables['content']['field_main_image']);
    $variables['attributes']['class'][] = 'teaser-conditional-no-image';
  }
  else {
    $variables['attributes']['class'][] = 'teaser-conditional-with-image';
  }

  // See if we're on a story list where the story labels don't make sense.
  // Since the story label is conditional on the page we're viewing, the
  // resulting render array can only be cached per route/page.
  $variables['#cache']['contexts'][] = 'route';
  $route_parameters = \Drupal::routeMatch()->getParameters();
  if ($route_parameters) {
    $view_id = $route_parameters->get('view_id');
    if (!empty($view_id) && $view_id == 'sw_section_stories') {
      $arg_0 = $route_parameters->get('arg_0');
      if (!empty($arg_0)) {
        switch (strtolower($arg_0)) {
          case 'editorials':
          case 'readers’-views':
          case 'obrero-socialista':
            // @todo It'd be better not to compute these in the first place...
            unset($variables['story_label']);
            break;
        }
      }
    }
    elseif (!empty($view_id) && $view_id == 'sw_recent') {
      unset($variables['date']);
    }
    elseif (!empty($view_id) && $view_id == 'sw_series_stories') {
      // Sort of ugly. It's not easy to get the currently active View object
      // to inquire directly about the taxonomy argument it's using. Call a
      // helper method to find the term given a URL argument.
      $arg_0 = $route_parameters->get('arg_0');
      $term = sw_get_term_from_path('series', $arg_0);
      if (!empty($term)) {
        // Since this render array is dependent upon fields on the taxonomy
        // term, add it to the #cache tags.
        $variables['#cache']['tags'][] = 'taxonomy_term:' . $term->id();
        // If the term doesn't want story labels, hide them.
        if (empty($term->get('field_show_story_labels')->value)) {
          unset($variables['story_label']);
        }
      }
    }
    else {
      $node = $route_parameters->get('node');
      if (!empty($node) && $node->getType() == 'person') {
        if ($variables['story_label'] == $node->getTitle()) {
          unset($variables['story_label']);
        }
      }
    }
  }
}

/**
 * Preprocess function for insert_box nodes.
 *
 * Replace the title (which is only for admins) with the display-appropriate title.
 * The display title is based on insert type, and optionally header_text.
 */
function sw_preprocess_node_insert_box(&$variables) {
  $insert_type = $variables['node']->get('field_insert_type')->entity;
  $header_text = $variables['node']->get('field_header_text')->value;
  $insert_title = $insert_type->label();

  switch ($insert_type->id()) {
    // If there's custom text, put the 'Series' part in a separate variable for
    // the twig template and use the custom text as the full label.
    case SW_INSERT_BOX_TYPE_SERIES_TID:
      if (!empty($header_text)) {
        $variables['insert_box_label'] = [
          // @todo: Should this be a more semantically accurate class name?
          '#prefix' => '<div class="story-label">',
          '#markup' => $insert_title,
          '#suffix' => '</div>',
        ];
        $insert_title = $header_text;
      }
      break;

    // Set the insert box title to only what's in the header text.
    case SW_INSERT_BOX_TYPE_CUSTOM_TID:
      if (!empty($header_text)) {
        $insert_title = $header_text;
      }
      break;

    // Append the header text to the term name as the insert box title.
    case SW_INSERT_BOX_TYPE_COLUMNIST_TID:
    case SW_INSERT_BOX_TYPE_REVIEW_TID:
      if (!empty($header_text)) {
        $insert_title .= ': ' . $header_text;
      }
      break;

  }
  $variables['label'] = $insert_title;
}

/**
 * Load entities pointed to via an entity_reference field into the host entity.
 *
 * The array of loaded entities is stuffed into the host entity at the 'sw_'
 * namespace, and will be keyed by entity IDs (as returned by whatever version
 * of Entity::loadMultiple() is passed in).
 *
 * @param EntityInterface $entity
 *   The host entity with an entity_reference field that points to the
 *   entities to load.
 * @param string $field_id
 *   Identifier for the entity_reference field to use (without the 'field_' prefix).
 */
function sw_load_referenced_entities(EntityInterface $entity, $field_id) {
  if (!isset($entity->{'sw_' . $field_id})) {
    $entity->{'sw_' . $field_id} = $entity->get('field_' . $field_id)->referencedEntities();
  }
}

function sw_load_story_people(NodeInterface &$story) {
  foreach (['authors', 'interviewees'] as $field_id) {
    sw_load_referenced_entities($story, $field_id);
  }
}

/**
 * Replaces %author and %interviewee tokens with the names (as links).
 *
 * @param \Drupal\node\NodeInterface $story
 *   The story for the right people to use for the token values.
 *
 * @param string $text
 *   The text to do the token replacement in.
 *
 * @param boolean $use_markup
 *   If true, the token replacements will be links to the author pages.
 *
 * @return string
 *   The new text, properly formatted with tokens replaced.
 */
function sw_replace_people_tokens(NodeInterface &$story, $text, $use_markup = TRUE) {
  if (strstr($text, '%author') !== FALSE || strstr($text, '%interviewee') !== FALSE) {
    sw_load_story_people($story);
    if (!empty($story->sw_authors)) {
      $token_values['%author'] = sw_get_entity_label_multiple($story->sw_authors, $use_markup ? 'sw_author_label' : 'sw_plain_label');
    }
    if (!empty($story->sw_interviewees)) {
      $token_values['%interviewee'] = sw_get_entity_label_multiple($story->sw_interviewees, $use_markup ? 'sw_subject_label' : 'sw_plain_label');
    }
    if (!empty($token_values)) {
      return strtr($text, $token_values);
    }
  }
  return $text;
}

function sw_contributor_sort($a, $b) {
  $a_name_parts = explode(' ', $a->label());
  $b_name_parts = explode(' ', $b->label());
  return strcmp(array_pop($a_name_parts), array_pop($b_name_parts));
}

/**
 * Label callback to return the plain entity label.
 */
function sw_plain_label(EntityInterface $entity) {
  return $entity->label();
};

/**
 * Label callback that wraps the entity label with author-specific markup.
 */
function sw_author_label(EntityInterface $entity) {
  return '<span class="sw-author">' . $entity->toLink()->toString() . '</span>';
};

/**
 * Label callback that wraps the entity label with subject-specific markup.
 *
 * Used for interviewee, obituary, etc.
 */
function sw_subject_label(EntityInterface $entity) {
  return '<span class="sw-subject">' . $entity->toLink()->toString() . '</span>';
};

/**
 * Generate the appropriate story label for a given story.
 *
 *  Pseudocode for the logic is as follows:
 *  if (section exists && section != ‘Movement News’) {
 *    $story_label = $section_name;
 *  }
 *  elseif (story type is interview || obituary ) {
 *    Story label = “$story_type: $interviewees” // (not the $authors)
 *  }
 *  elseif (story type is roundtable or custom) {
 *    Story label = the story type
 *  }
 *  elseif (story has authors ) {
 *    Story label = $author(s)
 *  }
 *  else {
 *    // no story label
 *  }
 *
 * @param \Drupal\node\NodeInterface $node
 *   A story node entity to generate the story label for.
 *
 * @param string $view_mode
 *   The view mode we're displaying the story with.
 *
 * @return string
 *   The story label (basically, the "byline") for the story.
 */
function sw_get_story_label(NodeInterface $node, $view_mode) {
  $story_label = '';

  $use_markup = $view_mode === 'full';

  $section = $node->get('field_section')->getValue();
  $story_type = $node->get('field_story_type')->getValue();

  if (!empty($section[0]['target_id'])) {
    switch ($section[0]['target_id']) {
      case SW_SECTION_EDITORIALS_TID:
        $story_label = t('Editorial');
        break;

      case SW_SECTION_READERS_VIEWS_TID:
        $story_label = t("Readers’ View");
        break;

      case SW_SECTION_OBRERO_SOCIALISTA_TID:
        $story_label = t('Obrero Socialista');
        break;
    }
  }

  if (empty($story_label) && !empty($story_type[0]['target_id'])) {
    switch ($story_type[0]['target_id']) {
      case SW_STORY_TYPE_INTERVIEW_TID:
        $story_label = t('Interview');
        $target_field = 'sw_interviewees';
        break;

      case SW_STORY_TYPE_OBITUARY_TID:
        $story_label = t('Obituary');
        $target_field = 'sw_interviewees';
        break;

      case SW_STORY_TYPE_ROUNDTABLE_TID:
        $story_label = t('Roundtable');
        break;

      case SW_STORY_TYPE_CUSTOM_TID:
        $story_label = $node->get('field_story_label')->value;
        break;
    }
  }

  // Some stories are set as 'Interview' or 'Obituary' that don't define a
  // subject person. We have to handle that. If there are subject(s) defined,
  // add ': ' to the label before their name(s).
  if (!empty($target_field) && $target_field == 'sw_interviewees') {
    if (empty($node->sw_interviewees)) {
      $target_field = '';
    }
    else {
      $story_label .= ': ';
      $label_func = $use_markup ? 'sw_subject_label' : 'sw_plain_label';
    }
  }

  // Nothing special from section or story type, use the author(s) (if any).
  if (empty($story_label) && !empty($node->sw_authors)) {
    $target_field = 'sw_authors';
    $label_func = $use_markup ? 'sw_author_label' : 'sw_plain_label';
  }

  if (!empty($target_field)) {
    $story_label .= sw_get_entity_label_multiple($node->{$target_field}, $label_func);
  }

  // If all else fails, provide a fallback since we never want an empty story label.
  if (empty($story_label)) {
    $story_label = t('Report');
  }

  return $story_label;
}

/**
 * Returns an appropriate label given an array of entities.
 *
 * If there's only 1 entity, return the label.
 * If 2, use "LabelA and LabelB".
 * If 3 or more "Label1, ... LabelN-1 and LabelN".
 *
 * @param array $entities
 *   An array of objects that implement \Drupal\Core\Entity\EntityInterface.
 * @param callable $label_callback
 *   A function that takes an object that implements EntityInterface and
 *   returns the appropriate text or markup for the label for that Entity.
 *
 * @return string
 *   Label for all the entities with appropriate delimiter(s) depending on number.
 */
function sw_get_entity_label_multiple(array $entities, $label_callback) {
  $text = '';
  $last = array_pop($entities);
  $last_label = $label_callback($last);
  $text = implode(', ', array_map($label_callback, $entities));
  if (!empty($text)) {
    $text .= " and $last_label";
  }
  else {
    $text = $last_label;
  }
  return $text;
}

/**
 * Returns the appropriate caption (if any) to use for a given media entity.
 *
 * @param integer $entity_id
 *   The ID of the entity we're considering.
 *
 * @return string
 *   The appropriate caption, or NULL if there is none.
 */
function sw_get_media_caption($entity_id) {
  $entity = Drupal\media\Entity\Media::load($entity_id);
  if (!empty($entity) && $entity->bundle() == 'image') {
    $caption = '';
    $default_caption = $entity->get('field_default_caption')->value;
    $credits = $entity->get('field_credit')->referencedEntities();
    $provider = $entity->get('field_image_provider')->entity;
    if (!empty($default_caption)) {
      $caption = $default_caption;
    }
    if (!empty($credits)) {
      // If there's already a caption, add a space before credits.
      $caption .= empty($caption) ? '(' : ' (';
      $caption .= implode(', ', array_map('sw_plain_label', $credits));
    }
    if (!empty($provider)) {
      if (!empty($credits)) {
        // If there's already credits, separate the provider with '|'.
        $caption .= ' | ';
      }
      elseif (!empty($caption)) {
        // Otherwise, if there's a caption, we need a space.
        $caption .= ' (';
      }
      else {
        // Otherwise, the provider is the only caption, no space.
        $caption .= '(';
      }
      $caption .= $provider->label();
    }
    if (!empty($credits) || !empty($provider)) {
      $caption .= ')';
    }
    return $caption;
  }
  elseif (!empty($entity) && $entity->bundle() == 'book') {
    // Start with the book title.
    $caption = $entity->label();
    $book_caption = $entity->get('field_book_caption')->value;
    if (!empty($book_caption)) {
      $caption .= ' | ' . $book_caption;
    }
    return $caption;
  }
}

/**
 * Implements hook_preprocess_HOOK() for media entities.
 */
function sw_preprocess_media(&$variables) {
  switch ($variables['media']->bundle()) {
    case 'image':
      if ($variables['view_mode'] == 'browser') {
        $variables['content']['mid'] = [
          // @todo Should this be a <label>?
          '#markup' => '<strong>' . t('Media ID:') . '</strong> ' . $variables['media']->id(),
          '#weight' => 50,
        ];
      }
      break;

  }
}

/**
 * Implements hook_ENTITY_TYPE_embed_alter().
 *
 * Preserves 'data-entity-id' while embedding entities so our custom caption
 * filter can load the embedded entity when it needs it. Also sticks the value
 * of data-view-mode as a class on the container element.
 */
function sw_media_embed_alter(array &$build, EntityInterface $entity, array &$context) {
  $build['#attributes']['data-entity-id'] = $context['data-entity-id'];
  $build['#attributes']['class'][] = str_replace('_', '-', $context['data-view-mode']);
}

/**
 * Implements hook_block_view_alter().
 *
 * @param array $build
 * @param \Drupal\Core\Block\BlockPluginInterface $block
 */
function sw_block_view_alter(array &$build, BlockPluginInterface $block) {
  if ($block instanceof SWTodaysStoriesBlock) {
    $build['#configuration']['label'] = $block->label();
    $build['#cache']['max-age'] = 86400; // 1 day = 60 * 60 * 24
  }
}

/**
 * Implements hook_theme().
 */
function sw_theme() {
  return [
    'sw_mailerlite_subscribe_form' => [
      'variables' => [
        'form_type' => NULL,
        'email_value' => NULL,
      ],
    ],
  ];
}

/**
 * Prepares variables for MailerLite subscribe form.
 *
 * Default template: sw-mailerlite-subscribe-form.html.twig
 *
 * @param array $variables
 *   An associative array containing:
 *   - form_type: Either 'page' or 'block'.
 *
 */
function template_preprocess_sw_mailerlite_subscribe_form(&$variables) {
  $form_classes[] = 'ml-block-form';
  $form_classes[] = 'sw-mailerlite-form-' . $variables['form_type'];
  $variables['form_classes'] = 'class="' . implode(' ', $form_classes) . '"';
  if ($variables['form_type'] == 'page') {
    $variables['form_intro'] = t('SocialistWorker.org sends out e-mail alerts to let subscribers know about new articles that have been posted and point out special features on our site.');
  }
  else {
    $variables['form_intro'] = t('Get e-mail alerts from SocialistWorker.org');
  }
}

/**
 * Helper function to find the taxnomy term from a given URL argument.
 *
 * Uses a static cache to avoid doing lots of entity load on a story list.
 *
 * @param string $vocabulary
 *  The machine name of the vocabulary we expect to find the term in.
 * @param string $url_arg
 *  The portion of a URL that points to a specific term. Usually the same as the
 *  term name, but with spaces converted to '-' and all lower case.
 *
 * @return \Drupal\taxonomy\TermInterface
 *  A fully-loaded taxonomy term entity that matches, or NULL if not found.
 */
function sw_get_term_from_path($vocabulary, $url_arg) {
  static $terms = [];
  if (!isset($terms[$vocabulary][$url_arg])) {
    $values = [
      'vid' => $vocabulary,
      'name' => str_replace('-', ' ', $url_arg),
    ];
    $term_entities = \Drupal::entityManager()->getStorage('taxonomy_term')->loadByProperties($values);
    $terms[$vocabulary][$url_arg] = !empty($term_entities) ? reset($term_entities) : NULL;
  }
  return $terms[$vocabulary][$url_arg];
}

/**
 * @param \Drupal\node\NodeInterface $node
 *   The fully-loaded node entity that contains the series insert box.
 *
 * @return \Drupal\taxonomy\TermInterface
 *   A fully-loaded taxonomy term entity for the series, or NULL if there is none.
 */
function sw_get_series_term(NodeInterface $node) {
  $series_value = $node->get('field_series')->getValue();
  if (!empty($series_value[0])) {
    $series_terms = Term::loadMultiple($series_value[0]);
    if (!empty($series_terms)) {
      return reset($series_terms);
    }
  }
}

/**
 * Generate the render array for the automagic series insert box.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The fully-loaded node entity that contains the series insert box.
 *
 * @return array
 *   A render array for the insert box.
 *
 * @todo Maybe this whole thing should be converted into a twig template.
 */
function sw_insert_series_box(NodeInterface $node) {
  // The render array is dependent upon edits to the host node.
  $build['#cache']['tags'][] = 'node:' . $node->id();
  $series_term = sw_get_series_term($node);

  // If there's no series for this story, bail early.
  if (empty($series_term)) {
    // @todo: Should we log something to the watchdog about this? This is an
    // error condition.
    return $build;
  }

  // The render array is dependent upon edits to the series term.
  $build['#cache']['tags'][] = 'taxonomy_term:' . $series_term->id();
  $build += [
    '#prefix' => '<article class="node--type-insert-box series">',
    '#suffix' => '</article>',
    'header' => [
      '#prefix' => '<a href="' . sw_get_series_url($series_term)->toString() . '">',
      '#suffix' => '</a>',
      'label' => [
        // @todo: Should this be a more semantically accurate class name?
        '#prefix' => '<div class="story-label">',
        '#markup' => t('Series'),
        '#suffix' => '</div>',
      ],
      'title' => [
        '#prefix' => '<h2>',
        '#markup' => $series_term->getName(),
        '#suffix' => '</h2>',
      ],
    ],
  ];
  $description = $series_term->getDescription();
  if (!empty($description)) {
    $build['description'] = [
      '#prefix' => '<p class="description">',
      '#markup' => $description,
      '#suffix' => '</p>',
    ];
  }
  $story_list_length = $series_term->get('field_series_insert_list_length')->value;
  if (!empty($story_list_length)) {
    $show_story_label = $series_term->get('field_show_story_labels')->value;
    $items = [];
    foreach (sw_get_series_stories($series_term, $story_list_length) as $nid => $story) {
      $items[] = sw_get_story_render_array($story, $show_story_label);
    }
    $build['stories'] = [
      '#theme' => 'item_list',
      '#list_type' => 'ul',
      '#items' => $items,
      '#wrapper_attributes' => [
        'class' => 'story-list',
      ],
    ];
  }
  // Unless we're already showing all the articles as a story list, provide an
  // explicit link to the whole series page.
  if ($story_list_length != -1) {
    $build['all_link'] = [
      '#type' => 'link',
      '#title' => t('All articles in this series'),
      '#url' => sw_get_series_url($series_term),
      '#prefix' => '<p class="all-link">',
      '#suffix' => '</p>',
    ];
  }
  return $build;
}

/**
 * Returns a render array for a given story.
 *
 * @param array $story
 *   An array of story data, with keys 'nid' and 'title'.
 * @param boolean $show_story_label
 *   Boolean that controls if the render array should include a story label.
 *
 * @return array
 *   A valid render array to display the given story.
 *
 * @see sw_get_story_label()
 */
function sw_get_story_render_array(array $story, $show_story_label = FALSE) {
  // Use absolute URLs so that these sorts of links work fine in emails, RSS, etc.
  $node_url = new Url('entity.node.canonical', ['node' => $story['nid']], ['absolute' => TRUE]);
  $build = [
    '#prefix' => '<a class="story-link" href="' . $node_url->toString() . '">',
    '#suffix' => '</a>',
    // This render array is dependent upon edits to the story we're displaying.
    '#cache' => ['tags' => ['node:' . $story['nid']]],
  ];
  if ($show_story_label) {
    // @todo: If we denormalize the story_label into a separate field, we
    // don't need to incur the cost of all the full entity loads here.
    $node = Node::load($story['nid']);
    foreach (['authors', 'interviewees'] as $field_id) {
      sw_load_referenced_entities($node, $field_id);
    }
    $build['story_label'] = [
      '#markup' => sw_get_story_label($node, 'teaser'),
      '#prefix' => '<div class="story-label">',
      '#suffix' => '</div>',
    ];
  }
  $build['headline'] = [
    '#markup' => $story['title'],
    '#prefix' => '<h4 class="headline">',
    '#suffix' => '</h4>',
  ];
  return $build;
}

/**
 * Helper function to get the path to a series series list.
 *
 * @param \Drupal\taxonomy\TermInterface $series_term
 *   A fully loaded taxonomy entity representing the series.
 *
 * @return \Drupal\Core\Url
 *   The Url object for the link to the series story list page.
 */
function sw_get_series_url(TermInterface $series_term) {
  $path_arg = str_replace([' ', '?'], ['-', '%3F'], strtolower($series_term->getName()));
  return Url::fromUri('internal:/series/' . $path_arg);
}

/**
 * Build an array of stories belonging to a given series.
 *
 * Uses a static cache to avoid querying for the story list multiple times on
 * the same page load.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   The fully-loaded taxonomy term entity for the series.
 * @param integer $length
 *   Length of the story list. Use -1 for unlimited, 0 for no list, otherwise,
 *   the specific limit.
 *
 * @return array
 *   Array of stories from the series, in chronological order. Keys are node ID
 *   (nid). Values are nested arrays with 'nid' and 'title' keys.
 */
function sw_get_series_stories(TermInterface $term, $length = -1) {
  static $stories = [];
  if (empty($stories[$term->id()][$length])) {
    $query = \Drupal::database()->select('node_field_data', 'nfd')
      ->fields('nfd', ['nid', 'title']);
    $query->join('taxonomy_index', 'ti', 'nfd.nid = ti.nid');
    $query->condition('ti.tid', $term->id(), '=');
    $query->orderBy('nfd.created', 'ASC');
    if ($length != -1) {
      $query->range(0, $length);
    }
    $stories[$term->id()][$length] = $query->execute()->fetchAllAssoc('nid', PDO::FETCH_ASSOC);
  }
  return $stories[$term->id()][$length];
}

/**
 * Find the 'prev' and 'next' links for a given story within a series.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The fully-loaded node entity for the story.
 * @param \Drupal\taxonomy\TermInterface $series
 *   The fully-loaded taxonomy term entity for the series.
 *
 * @return array
 *   Array keyed with 'next' and 'prev', where values are render arrays for
 *   links to the appropriate stories, or NULL if there's no appropriate link.
 *   E.g. 'prev' will be NULL if we're on the first article in a series.
 */
function sw_get_series_navigation(NodeInterface $node, TermInterface $series) {
  $prev = $next = NULL;
  $stories = sw_get_series_stories($series);
  // We used to use each() for this, but that's now deprecated.
  // foreach() is the "safe" and recommended way, but we can't rely on it using
  // the internal array pointer, so tricks with next() or prev() aren't safe.
  // So, we fudge it with a flag, let foreach iterate, and we never care about
  // the internal array pointer.
  $break_on_next = FALSE;
  foreach ($stories as $story) {
    // If we already hit the current article and set the flag, foreach will have
    // just given us the next story and we should set that as our next link
    // before we break out of the loop.
    if ($break_on_next) {
      $next = $story;
      break;
    }
    // If we're on the current story, set a flag to know we want to break out of
    // the loop on the next iteration. If this is the last story in the series,
    // foreach will bail before we can set $next, which is exactly what we want.
    if ($story['nid'] == $node->id()) {
      $break_on_next = TRUE;
    }
    // Otherwise, remember this story as the "previous" link in case the next
    // article in the array is the story we're building navigation for.
    else {
      $prev = $story;
    }
  }
  return [
    'prev' => empty($prev) ? NULL : sw_get_story_render_array($prev),
    'next' => empty($next) ? NULL : sw_get_story_render_array($next),
  ];
}

/**
 * Find (and remember) the issue number taxonomy term of the current page (if any).
 *
 * @param \Drupal\views\ViewExecutable $view
 *   The ViewExecutable for the current page. We harvest the argument to load
 *   the term directly.
 *
 * @return \Drupal\taxonomy\TermInterface
 *   The full-loaded taxonomy_term entity for the current issue_number term.
 */
function sw_get_issue_term(ViewExecutable $view = NULL) {
  static $issue_term = NULL;
  if (empty($issue_term)) {
    if (!empty($view) && $view->id() == 'sw_issue_stories' && !empty($view->argument['tid']->argument)) {
      $issue_term = Term::load($view->argument['tid']->argument);
    }
  }
  return $issue_term;
}

/**
 * Implements hook_preprocess_HOOK() for 'html' template.
 *
 * Sets the HTML <title> for issue listing pages if we know the publication date.
 */
function sw_preprocess_html(&$variables) {
  $renderer = \Drupal::service('renderer');
  $path_matcher = \Drupal::service('path.matcher');
  $route_match = \Drupal::routeMatch();
  $node = $route_match->getParameter('node');
  $view_id = $route_match->getParameter('view_id');
  // todo
  // $site_name = variable_get('site_name', t('SocialistWorker.org'));
  $site_name = t('SocialistWorker.org');

  if (!empty($view_id) && $view_id == 'sw_issue_stories') {
    $issue_term = sw_get_issue_term();
    if (!empty($issue_term)) {
      $issue_date = $issue_term->get('field_issue_date')->value;
      if (!empty($issue_date)) {
        $title_args = [
          '@num' => $issue_term->label(),
          '@date' => $issue_date,
        ];
        $variables['head_title']['title'] = t('Issue @num: @date', $title_args);
      }
    }
  }
  elseif ($path_matcher->isFrontPage()) {
    $variables['head_title']['title'] = t('Daily news and opinion from the left');
    // @todo
    // variable_get('sw_meta_description',
    $meta_description = t('Daily news and opinion site based in the U.S., with reports from struggles around the world and left-wing analysis of political events.');
    $meta_tags = [
      ['property' => 'og:title', 'name' => 'title', 'content' => $site_name],
      ['property' => 'og:description', 'name' => 'description', 'content' => $meta_description],
      ['property' => 'og:url', 'content' => Url::fromRoute('<front>', [], ['absolute' => TRUE])->toString()],
      ['name' => 'google-site-verification', 'content' => 'mN5MrkxGGmnBKwcDL0mSz7us2M2d4xwpfzHnUsQJVjU'],
    ];
  }
  elseif (!empty($node) && $node->bundle() == 'story') {
    $clean_title = strip_tags($node->label());
    $meta_tags = [
      ['property' => 'og:title', 'name' => 'title', 'content' => $clean_title],
      ['property' => 'og:url','content' => $node->toUrl('canonical', ['absolute' => TRUE])->toString()],
      ['property' => 'og:updated_time', 'content' => $node->get('changed')->value],
      ['property' => 'og:type', 'content' => 'article'],
      ['property' => 'article:publisher', 'content' => 'https://www.facebook.com/socialistworker'],
      ['property' => 'twitter:card', 'content' => 'summary_large_image'],
      ['property' => 'twitter:site', 'content' => '@SocialistViews'],
      ['property' => 'twitter:creator', 'content' => '@SocialistViews'],
      ['name' => 'twitter:title', 'content' => $clean_title],
    ];
    $sections = $node->get('field_section')->referencedEntities();
    if (!empty($sections)) {
      $meta_tags[] = [
        'property' => 'article:section',
        'content' => $sections[0]->label(),
      ];
    }
    $teaser = $node->get('field_teaser')->getValue();
    if (!empty($teaser[0]['value'])) {
      $build = [
        '#type' => 'processed_text',
        '#text' => $teaser[0]['value'],
        '#format' => $teaser[0]['format'],
      ];
      $teaser_content = trim(strip_tags($renderer->renderPlain($build)));
      $meta_tags[] = [
        'name' => 'description',
        'property' => 'og:description',
        'content' => $teaser_content,
      ];
      $meta_tags[] = [
        'name' => 'twitter:description',
        'content' => $teaser_content,
      ];
    }
    // Find an image to prefer for social media sharing.
    // If we have field_wide_image, use that.
    $wide_image = $node->get('field_wide_image')->getValue();
    if (!empty($wide_image[0]['target_id'])) {
      $share_media = $node->get('field_wide_image')->referencedEntities();
    }
    // Otherwise, fall back to field_main_image (if possible).
    else {
      $main_image = $node->get('field_main_image')->getValue();
      if (!empty($main_image[0]['target_id'])) {
        $share_media = $node->get('field_main_image')->referencedEntities();
      }
    }
    // If we found something, use it.
    if (!empty($share_media)) {
      $share_image = $share_media[0]->get('field_media_image')->referencedEntities();
      if (!empty($share_image[0])) {
        $share_url = $share_image[0]->url();
        $share_image_info = $share_media[0]->get('field_media_image')->getValue();
        $meta_tags[] = [
          'property' => 'og:image',
          'content' => $share_url,
        ];
        $meta_tags[] = [
          'property' => 'og:image:type',
          'content' => $share_image[0]->getMimeType(),
        ];
        $meta_tags[] = [
          'property' => 'og:image:width',
          'content' => $share_image_info[0]['width'],
        ];
        $meta_tags[] = [
          'property' => 'og:image:height',
          'content' => $share_image_info[0]['height'],
        ];
        $meta_tags[] = [
          'name' => 'twitter:image',
          'content' => $share_url,
        ];
      }
    }
  }
  // Global properties, regardless of page:
  $meta_tags[] = ['property' => 'og:site_name', 'content' => $site_name];
  $meta_tags[] = ['property' => 'fb:app_id', 'content' => '2060345944288694'];

  // Finally, set all the meta tags we found for this page.
  foreach ($meta_tags as $meta_tag) {
    $id = !empty($meta_tag['name']) ? $meta_tag['name'] : $meta_tag['property'];
    $variables['page']['#attached']['html_head'][] = [
      ['#tag' => 'meta', '#attributes' => $meta_tag],
      $id,
    ];
  }
}

/**
 * Implements hook_preprocess_HOOK() for the 'page' template.
 *
 * Sets a page template variable for the "story-label" for issue # story lists.
 */
function sw_preprocess_page(&$variables) {
  $view_id = \Drupal::routeMatch()->getParameter('view_id');
  if (!empty($view_id) && $view_id == 'sw_issue_stories') {
    $issue_term = sw_get_issue_term();
    if (!empty($issue_term)) {
      $issue_date = $issue_term->get('field_issue_date')->value;
      // If we have an issue date, that'll become the main page title.
      // Use the issue number as the prefix in "story label" style.
      if (!empty($issue_date)) {
        $variables['issue_list_prefix'] = t('Issue @num', ['@num' => $issue_term->label()]);
      }
    }
  }
  $node = \Drupal::routeMatch()->getParameter('node');
  if ($node) {
    switch ($node->bundle()) {
      case 'blog_critical_reading':
        $variables['story_label'] = t('From the Critical Reading blog');
        break;

      case 'blog_couldnt_make_it_up':
        $variables['story_label'] = t('From the Couldn’t Make It Up blog');
        break;

    }
  }
}

/**
 * Implements hook_views_pre_render().
 *
 * Alters the issue story list view to hide stories that are already listed as
 * 'Top stories'. Since this runs relatively early in the page generation, it
 * also lets us initialize sw_get_issue_term() with the $view object so we can
 * load the term directly via tid from the view argument.
 *
 * @param \Drupal\views\ViewExecutable $view
 *   The ViewExecutable for the view we're about to render.
 *
 * @see sw_get_issue_term()
 */
function sw_views_pre_render(ViewExecutable $view) {
  switch ($view->id()) {
    case 'sw_issue_stories':
      return sw_views_pre_render_sw_issue_stories($view);

    case 'sw_recent':
      return sw_views_pre_render_sw_recent($view);

    case 'sw_search':
      return sw_views_pre_render_sw_search($view);

  }
}

/**
 * Implements hook_views_pre_render() for the issue story list.
 */
function sw_views_pre_render_sw_issue_stories(ViewExecutable $view) {
  // We only want to filter these stories out of the page display. We need
  // the full list for the entity_reference display.
  if ($view->getDisplay()->getPluginId() == 'page') {
    $issue_term = sw_get_issue_term($view);
    // Clobber the page title with the issue date.
    $issue_date = $issue_term->get('field_issue_date')->value;
    if (!empty($issue_date)) {
      $view->setTitle($issue_date);
    }
    // If field_issue_top_stories is defined, remove them from the view list.
    $top_stories = $issue_term->get('field_issue_top_stories')->getValue();
    if (!empty($top_stories)) {
      $top_story_nids = [];
      foreach ($top_stories as $top_story) {
        if (!empty($top_story['target_id'])) {
          $top_story_nids[$top_story['target_id']] = TRUE;
        }
      }
      foreach ($view->result as $index => $result) {
        if (!empty($top_story_nids[$result->nid])) {
          unset($view->result[$index]);
        }
      }
    }
  }
}

/**
 * Implements hook_views_pre_render() for the recent feed.
 *
 * For editorials, swap out the author with a generic 'SocialistWorker.org' so
 * that the RSS feed doesn't leak the original authors (which are hidden on
 * story pages via custom story labels). Since the feed is directly setting
 * <dc:creator> via fields, not the 'rss' view mode, we can't fix this via
 * preprocess(). We need toalter the entity being used for the view results.
 */
function sw_views_pre_render_sw_recent(ViewExecutable $view) {
  if ($view->getDisplay()->getPluginId() == 'feed') {
    foreach ($view->result as $index => $result) {
      $section = $result->_entity->get('field_section')->getValue();
      if (!empty($section) && $section[0]['target_id'] == SW_SECTION_EDITORIALS_TID) {
        $result->_entity->set('field_authors', ['target_id' => SW_ORG_AUTHOR_NID]);
      }
      if (!empty($top_story_nids[$result->nid])) {
        unset($view->result[$index]);
      }
    }
  }
}

/**
 * Implements hook_node_pre_render() for search results.
 *
 * @see sw_views_pre_render_sw_search()
 */
function sw_preprocess_node_search_result(&$variables) {
  // Search result excerpts are different on every search query, so we have to
  // vary these render arrays by the route and full URL (including query args).
  $variables['#cache']['contexts'][] = 'route';
  $variables['#cache']['contexts'][] = 'url';
  if (!empty($variables['node']->sw_search_excerpt)) {
    // Copy the excerpt stashed in the $node object by
    // sw_views_pre_render_sw_search() into a variable for our twig template.
    $variables['search_excerpt'] = $variables['node']->sw_search_excerpt;
  }
  // The twig template makes the entire area a link, so we need to strip most
  // HTML from whatever is being rendered in here. Preserve a few tags.
  foreach ($variables['content'] as $field_name => $field) {
    if (!empty($variables['content'][$field_name][0]['#text'])) {
      $variables['content'][$field_name][0]['#text'] = strip_tags($variables['content'][$field_name][0]['#text'], '<p><em><i><cite><br>');
    }
  }
  if ($variables['node']->getType() == 'person') {
    $variables['content']['summary'] = [
      '#prefix' => '<p class="field--name-field-teaser">',
      '#markup' => t('Find all articles by and about this author.'),
      '#suffix' => '</p>',
    ];
    $variables['story_label'] = t('Author page');
    unset($variables['date']);

  }
}

/**
 * Implements hook_views_pre_render() for the search page.
 *
 * Stuffs the highlighted search result excerpts back into story teasers.
 * Since teasers get complicated on other node types, leave it as a separate
 * view field so we don't run into issues with summary trim limits, etc.
 */
function sw_views_pre_render_sw_search(ViewExecutable $view) {
  foreach ($view->result as $index => $result) {
    $node = $result->_object->getValue();
    if (!empty($result->search_api_excerpt) && !empty($node)) {
      $excerpt = $result->search_api_excerpt;
      unset($view->result[$index]->search_api_excerpt);
      // If the excerpt contains our custom person tokens, replace them now.
      if (strstr($excerpt, '%author') !== FALSE || strstr($excerpt, '%interviewee') !== FALSE) {
        if ($node->bundle() == 'story') {
          $excerpt = sw_replace_people_tokens($node, $excerpt, FALSE);
        }
      }
      // Since we set ['#cache']['contexts'][] = 'url' in sw_preprocess_node()
      // for all search_result render arrays, we're okay doing this here.
      $node->sw_search_excerpt = '<p class="highlighted-results">' . $excerpt . '<p>';
    }
  }
}

/**
 * Implements hook_cron().
 *
 * Handles delayed draft-to-live.
 */
function sw_cron() {
  $state_keys = ['sw_front_page_target_draft', 'sw_front_page_request_uid'];
  $values = \Drupal::state()->getMultiple($state_keys);

  // Anytime cron is running when the hour is between 0 (midnight) and 3am, if
  // there's a pending draft-to-live, run it.
  if (!empty($values['sw_front_page_target_draft']) && date('G') < 3) {

    // To ensure draft-to-live runs as the user who submitted the form, we
    // need to safely impersonate them here. This way, all node access checks
    // will do the right things, even when cron is being triggered anonymously.
    $user = User::load($values['sw_front_page_request_uid']);
    if (!empty($user)) {
      user_login_finalize($user);

      $draft_to_live = new DraftToLive($values['sw_front_page_target_draft'], $values['sw_front_page_request_uid']);
      $draft_to_live->execute(FALSE); // Don't render messages to the screen.

      \Drupal::state()->deleteMultiple($state_keys);

      // Return to user 0 (anonymous)
      $user = User::load(0);
      user_login_finalize($user);
    }
  }
}

/**
 * Build a query object to find stories associated with the given taxonomy terms.
 *
 * @param array $tids
 *   Array of numeric term IDs (TIDs) to search for.
 * @param array $exclude_nids
 *   Optional array of numeric nods IDs (NIDs) to exclude from the search.
 * @param integer $limit
 *   Optional maximum number of stories to return in the results.
 * @param integer $weight_max
 *   Optional limit on the story weight. If defined, only stories lighter (more
 *   important) than this maximum will be returned.
 *
 * @return \Drupal\Core\Database\Query\SelectInterface
 *   A Select query object for the story query.
 */
function sw_story_taxonomy_query(array $tids, $exclude_nids = [], $limit = 0, $weight_max = NULL) {
  $query = \Drupal::database()
    ->select('node_field_data', 'nfd')
    ->fields('nfd', ['nid']);
  $query->addExpression("DATE_FORMAT((DATE_ADD('19700101', INTERVAL nfd.created SECOND) + INTERVAL -18000 SECOND), '%Y%m%d')", 'created_day');
  $query->join('taxonomy_index', 'ti', 'nfd.nid = ti.nid');
  $query->join('node__field_story_weight', 'nfsw', 'nfd.nid = nfsw.entity_id AND nfd.vid = nfsw.revision_id');
  $query->condition('nfd.status', 1, '=')
    ->condition('nfd.type', 'story', '=')
    ->condition('ti.tid', $tids, 'IN');

  if (!empty($exclude_nids)) {
    $query->condition('nfd.nid', $exclude_nids, 'NOT IN');
  }
  if (isset($weight_max)) {
    // Limit the list to stories more important (lighter) than a given weight.
    $query->condition('nfsw.field_story_weight_value', $weight_max, '<=');
  }

  $query->orderBy('created_day', 'DESC');
  $query->orderBy('nfsw.field_story_weight_value', 'ASC');

  if (!empty($limit)) {
    $query->range(0, $limit);
  }

  return $query;
}

/**
 * Implements hook_form_FORM_ID_alter() for 'contact_message_readers_views_form'.
 *
 * Add a custom submit callback to see if the user is responding to a specific
 * story, and if so, redirect them back to the article page.
 */
function sw_form_contact_message_readers_views_form_alter(&$form, FormStateInterface $form_state) {
  $form['actions']['submit']['#submit'][] = 'sw_respond_page_submit';
}

/**
 * Form submit callback to redirect after sending an email response to a story.
 */
function sw_respond_page_submit(array $form, FormStateInterface $form_state) {
  $reply_story = $form_state->getValue('field_reply_story');
  if (!empty($reply_story[0]['target_id'])) {
    $node = Node::load($reply_story[0]['target_id']);
    if (!empty($node)) {
      $form_state->setRedirectUrl($node->toUrl());
    }
  }
}

/**
 * Implements hook_preprocess_forward().
 */
function sw_preprocess_forward(&$variables) {
  if (empty($variables['message']['#markup']) && empty($variables['message']['#plain_text'])) {
    unset($variables['message']);
  }
  $variables['email_subscribe_form'] = [
    '#theme' => 'sw_mailerlite_subscribe_form',
    '#form_type' => 'block',
    '#email_value' => $variables['recipient'],
  ];
  // Fix the link to remove the 'Read more about' text.
  $variables['link'] = $variables['entity']->toLink(NULL, 'canonical', ['absolute' => TRUE]);

  // Add the site footer text as a template variable.
  $block_manager = \Drupal::service('plugin.manager.block');
  $plugin_block = $block_manager->createInstance('simple_block:footer_social', []);
  $variables['site_footer'] = $plugin_block->build();
}

/**
 * Implements hook_ENTITY-TYPE_presave() for 'file' entities.
 *
 * Enforces server-friendly filenames on anything uploaded to SW.org.
 *
 * @see sw_clean_filename()
 */
function sw_file_presave(EntityInterface $file) {
  $orig_uri = $file->getFileUri();
  $orig_filename = $file->getFilename();
  $path_info = pathinfo($orig_uri);
  $clean_filename = sw_clean_filename($orig_filename);
  $new_uri = $path_info['dirname'] . '/' . $clean_filename;
  if ($new_uri != $orig_uri) {
    if ($uri = file_unmanaged_move($orig_uri, $new_uri, FILE_EXISTS_RENAME)) {
      $new_filename = basename($uri);
      drupal_set_message(t('Renamed file from %orig to %new for safe storage on the server.',
                           ['%orig' => $orig_filename, '%new' => $new_filename]));
      $file->setFileUri($uri);
      $file->setFilename($new_filename);
    }
    else {
      // @todo: Now what?
    }
  }
}

/**
 * Clean and sanitize a filename for use on SW.org.
 *
 * This code is shared with the migration, and when new files are uploaded.
 *
 * @param string $filename
 *   The original (potentially absurd) filename from the SW team.
 *
 * @return string
 *   A sanitized, transliterated and lowercase filename.
 *
 * @see sw_file_presave()
 * @see \Drupal\sw_migrate\Plugin\migrate\process\SWFileUri::transform()
 */
function sw_clean_filename($filename) {
  // Transliterate to bring some initial sanity.
  $name = \Drupal::service('transliteration')->transliterate($filename, 'en', '_');

  // Convert anything not a letter, number, '.', '-' or '_' to an underscore.
  $name = preg_replace('/[^\w\.\-]+/', '_', $name);

  // Consolidate repeated punctuation:
  // If we see '.' anywhere in a chain of punctuation, keep it:
  $name = preg_replace('/[_\-\.]*\.[_\-\.]*/', '.', $name);
  // Otherwise, consolidate 2 or more '_' and/or '-' into a single '_'.
  $name = preg_replace('/[_\-]{2,}/', '_', $name);

  // Strip leading punctuation.
  $name = ltrim($name, '._-');

  // We want all lowercase, but before we do, convert CamelCase to use _ delimiters.
  // @see https://stackoverflow.com/questions/40514051/using-preg-replace-to-convert-camelcase-to-snake-case
  // Modified to ignore numbers and just put _ when we move from lower to upper.
  $name = strtolower(preg_replace('/(?<=[a-z])(?=[A-Z])/', '_', $name));

  return $name;
}

/**
 * Implements template_preprocess_image_formatter().
 *
 * Automatically sets image alt attributes to the default caption from their image node (if possible).
 */
function sw_preprocess_image_formatter(&$variables) {
  $parent_entity = $variables['item']->getEntity();
  $bundle = $parent_entity->bundle();
  if ($bundle == 'image') {
    $default_caption = $parent_entity->get('field_default_caption')->getValue();
    if (!empty($default_caption[0]['value'])) {
      $variables['image']['#alt'] = trim(strip_tags(check_markup($default_caption[0]['value'], $default_caption[0]['format'])));
    }
  }
  elseif ($bundle == 'book') {
    $variables['image']['#alt'] = t('Cover image: @title', ['@title' => $parent_entity->label()]);
  }
  if (empty($variables['image']['#alt'])) {
    $variables['image']['#alt'] = t('Image from SocialistWorker.org');
  }
  unset($variables['image']['#title']);
}

/**
 * Implements hook_preprocess_views_view().
 */
function sw_preprocess_views_view(&$variables) {
  $entity_browser_views = [
    'sw_media_entity_browser',
    'sw_content_entity_browser',
    'sw_entityqueue_browser',
  ];
  if (in_array($variables['view']->id(), $entity_browser_views)) {
    $variables['view_array']['#attached']['library'][] = 'sw/entity-browser';
  }
}

/**
 * Implements hook_pathauto_punctuation_chars_alter().
 */
function sw_pathauto_punctuation_chars_alter(array &$punctuation) {
  $punctuation['fancy-quote-open-single'] = ['value' => '‘', 'name' => t('Fancy quote - open single')];
  $punctuation['fancy-quote-close-single'] = ['value' => '’', 'name' => t('Fancy quote - close single')];
  $punctuation['fancy-quotes-open-double'] = ['value' => '“', 'name' => t('Fancy quotes - open double')];
  $punctuation['fancy-quotes-close-double'] = ['value' => '”', 'name' => t('Fancy quotes - close double')];
}

/**
 * Implements hook_search_api_solr_query_alter().
 *
 * Boost more recent content in search results.
 *
 * This sends a 'boost' function that uses date math to demote older stuff
 * using an exponential age function.
 *
 * Details about the diff between bf and 'boost' function in
 * https://nolanlawson.com/2012/06/02/comparing-boost-methods-in-solr/
 *
 * Explanation of the function:
 * https://www.metaltoad.com/blog/date-boosting-solr-drupal-search-results
 *
 * OLD howto:
 * https://www.drupal.org/node/2194055
 *
 * Works in D8 & Current Solr:
 * https://www.drupal.org/node/2823538
 */
function sw_search_api_solr_query_alter(\Solarium\QueryType\Select\Query\Query $solarium_query, \Drupal\search_api\Query\QueryInterface $query) {
  // 'boost' is a solr keyword.
  $solarium_query->addParam(
    'boost',
    'recip(abs(ms(NOW/HOUR,ds_created)),3.16e-11,1,.1)'
  );
}
