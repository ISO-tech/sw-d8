<?php

/**
 * @file
 * Contains custom code necessary for SW migrations.
 */

use Drupal\migrate\Plugin\MigrateSourceInterface;
use Drupal\migrate\Plugin\MigrationInterface;
use Drupal\migrate\Row;

/**
 * Migrate callback function to map story weights into the new values.
 *
 * @param array $story_weight
 *   Nested array keyed by 'value' and 'delta'. We only care about the value.
 *
 * @return integer
 *   The story weight in D8 (-10 to 10) based on the D6 values (-5 to 5).
 */
function sw_migrate_story_weight_map(array $story_weight) {
  switch ($story_weight['value']) {
    case -5:
      return -9;
    case -4:
      return -6;
    case -3:
      return -3;
    case -2:
      return -1;
    case -1:
      return 1;
    case 0:
      return 3;
    case 1:
      return 5;
    case 2:
      return 7;
    case 3:
      return 8;
    case 4:
      return 9;
    case 5:
      return 10;
  }
}

/**
 * Implements hook_migrate_MIGRATION_ID_prepare_row() for 'upgrade_d6_file'.
 *
 * If the D6 {files} table has an empty timestamp, lookup the creation date of
 * the image node the file is attached to (if possible).
 */
function sw_migrate_migrate_upgrade_d6_file_prepare_row(Row $row, MigrateSourceInterface $source, MigrationInterface $migration) {
  $values = $row->getSource();
  $img_timestamp = 0;
  if (empty($values['timestamp'])) {
    $img_timestamp = $source
      ->getDatabase()
      ->query('SELECT n.created FROM {content_type_image} c INNER JOIN {node} n ON c.vid = n.vid WHERE c.field_image_fid = :fid', [
        ':fid' => $values['fid']
      ])
      ->fetchField();
  }
  $row->setSourceProperty('img_timestamp', $img_timestamp);
}

/**
 * Implements hook_migrate_MIGRATION_ID_prepare_row() for 'upgrade_d6_taxonomy_term'.
 *
 * Count the number of nodes associated with each term.
 *
 * Set a 'valid_term' property in the source row only if the vocabulary is
 * 'Topics' or 'Image galleries' (where we always preserve the terms) or the
 * term is associated with at least 1 node.
 *
 * @see http://tasks.socialistworker.org/node/983
 */
function sw_migrate_migrate_upgrade_d6_taxonomy_term_prepare_row(Row $row, MigrateSourceInterface $source, MigrationInterface $migration) {
  $values = $row->getSource();
  $node_count = $source->getDatabase()
      ->query('SELECT COUNT(*) FROM {term_node} tn INNER JOIN {node} n ON tn.vid = n.vid WHERE tn.tid = :tid', [
        ':tid' => $values['tid']
      ])
      ->fetchField();
  $row->setSourceProperty('node_count', $node_count);
  // Terms from topic (2) and image gallery (14) are always valid.
  // Otherwise, this term is only worth migrating if it has nodes.
  $valid_term = $values['vid'] == 2 || $values['vid'] == 14 || !empty($node_count);
  $row->setSourceProperty('valid_term', $valid_term ? 1 : 0);

  // Special handling for terms in the department/section vocabulary:
  if ($values['vid'] == 1) {
    // Ignore department parent values, we want everything to be top-level as a section.
    $row->setSourceProperty('parent', 0);
    // Force the weights how we want in the new world:
    switch ($values['tid']) {
      case 11:    // Editorials
        $weight = 0;
        break;
      case 7:     // Labor
        $weight = 1;
        break;
      case 8:     // Activist News
        $weight = 2;
        break;
      case 6:     // History and Traditions
        $weight = 3;
        break;
      case 9:     // Readers' Views
        $weight = 4;
        break;
      case 17255: // Obrero Socialista
        $weight = 5;
        break;
    }
    if (isset($weight)) {
      $row->setSourceProperty('weight', $weight);
    }
  }  
}

/**
 * Implements hook_migrate_MIGRATION_ID_prepare_row() for 'upgrade_d6_node_story'.
 *
 * Handles section, topic and story type terms, and optional custom story label.
 *
 * @see http://tasks.socialistworker.org/node/982
 * @see http://tasks.socialistworker.org/node/984
 */
function sw_migrate_migrate_upgrade_d6_node_story_prepare_row(Row $row, MigrateSourceInterface $source, MigrationInterface $migration) {
  $values = $row->getSource();
  $node_terms = $source->getDatabase()
      ->query('SELECT td.tid, td.vid, td.name FROM {term_node} tn INNER JOIN {term_data} td ON td.tid = tn.tid WHERE tn.vid = :vid',
              [':vid' => $values['vid']])
      ->fetchAllAssoc('tid', PDO::FETCH_ASSOC);

  $node_vocabs = [];
  foreach ($node_terms as $tid => $term) {
    $node_vocabs[$term['vid']][$tid] = $term;
  }

  // Most departments are dropped, a few are merged. Use the callback map function.
  if (!empty($node_vocabs[1])) {
    $term = array_shift($node_vocabs[1]);
    $row->setSourceProperty('sw3_section_tid', sw_migrate_section_id_map($term['tid']));
  }

  // These are all migrated exactly as-is.
  $vocab_map = [
    2 => 'sw3_topic_tid',
    5 => 'sw3_issue_number_tid',
    12 => 'sw3_series_tid',
  ];
  foreach ($vocab_map as $vid => $sw3_id) {
    if (!empty($node_vocabs[$vid])) {
      $term = array_shift($node_vocabs[$vid]);
      $row->setSourceProperty($sw3_id, $term['tid']);
    }
  }

  // These are potentially multi-valued, and need array support.
  $multi_value_vocab_map = [
    4 => 'sw3_contributors_terms',
    6 => 'sw3_city_terms',
    7 => 'sw3_state_terms',
    8 => 'sw3_country_terms',
    9 => 'sw3_keywords_terms',
  ];
  foreach ($multi_value_vocab_map as $vid => $sw3_id) {
    if (!empty($node_vocabs[$vid])) {
      $row->setSourceProperty($sw3_id, $node_vocabs[$vid]);
    }
  }

  // Story type is a special case, since we have to see if we need to preserve
  // the SW 2.0 value as a custom story label.
  // First, set what we think the story_type_tid should be
  if (!empty($node_vocabs[10])) {
    $sw2_story_type_term = array_shift($node_vocabs[10]);
    $sw3_story_type_tid = sw_migrate_story_type_id_map($sw2_story_type_term['tid']);
  }
  // If the 2.0 story type is defined
  // AND the 3.0 story type is undefined
  // AND either the story has no authors
  //     OR the story has more than 3 authors
  if (!empty($sw2_story_type_term['tid'])
      && empty($sw3_story_type_tid)
      && (empty($values['field_authors'])
          || count($values['field_authors']) > 3)
  ) {
    // Save the 2.0 story type as a custom story label for 3.0.
    $row->setSourceProperty('sw3_story_label', $sw2_story_type_term['name']);
    $sw3_story_type_tid = SW_STORY_TYPE_CUSTOM_TID;
  }
  $row->setSourceProperty('sw3_story_type_tid', $sw3_story_type_tid);
}

/**
 * Implements hook_migrate_MIGRATION_ID_prepare_row() for 'upgrade_d6_node_insert_box'.
 *
 * Handles topic and insert type terms.
 */
function sw_migrate_migrate_upgrade_d6_node_insert_box_prepare_row(Row $row, MigrateSourceInterface $source, MigrationInterface $migration) {
  $values = $row->getSource();
  $node_terms = $source->getDatabase()
      ->query('SELECT td.tid, td.vid, td.name FROM {term_node} tn INNER JOIN {term_data} td ON td.tid = tn.tid WHERE td.vid IN (2, 13) AND tn.vid = :vid',
              [':vid' => $values['vid']])
      ->fetchAllAssoc('vid', PDO::FETCH_ASSOC);

  // There's no special re-mapping or filtering needed for either of these.
  $row->setSourceProperty('sw3_topic_tid', $node_terms[2]['tid']);
  $row->setSourceProperty('sw3_insert_type_tid', $node_terms[13]['tid']);
}

/**
 * Implements hook_migrate_MIGRATION_ID_prepare_row() for 'upgrade_d6_node_image'.
 *
 * Handles section, topic and story type terms
 */
function sw_migrate_migrate_upgrade_d6_node_image_prepare_row(Row $row, MigrateSourceInterface $source, MigrationInterface $migration) {
  $values = $row->getSource();
  $node_terms = $source->getDatabase()
      ->query('SELECT td.tid, td.vid, td.name FROM {term_node} tn INNER JOIN {term_data} td ON td.tid = tn.tid WHERE tn.vid = :vid',
              [':vid' => $values['vid']])
      ->fetchAllAssoc('tid', PDO::FETCH_ASSOC);

  $node_vocabs = [];
  foreach ($node_terms as $tid => $term) {
    $node_vocabs[$term['vid']][$tid] = $term;
  }

  // These are definitely single-value and migrated exactly as-is.
  $single_value_vocab_map = [
    14 => 'sw3_image_gallery_tid',
    15 => 'sw3_image_rights_tid',
  ];
  foreach ($single_value_vocab_map as $vid => $sw3_id) {
    if (!empty($node_vocabs[$vid])) {
      $term = array_shift($node_vocabs[$vid]);
      $row->setSourceProperty($sw3_id, $term['tid']);
    }
  }
  // These are potentially multi-valued, and need array support.
  $multi_value_vocab_map = [
    6 => 'sw3_city_terms',
    7 => 'sw3_state_terms',
    8 => 'sw3_country_terms',
    16 => 'sw3_image_provider_terms',
    17 => 'sw3_image_credit_terms',
    18 => 'sw3_image_server_folder_terms',
  ];
  foreach ($multi_value_vocab_map as $vid => $sw3_id) {
    if (!empty($node_vocabs[$vid])) {
      $row->setSourceProperty($sw3_id, $node_vocabs[$vid]);
    }
  }
}

/**
 * Migrate callback function to deal with taxonomy term IDs.
 *
 * This prunes terms from the Department/Section and Story type vocabularies
 * that we no longer need in SW 3.0. Used while creating the taxonomy terms
 * themselves via the update_d6_taxonomy_term migration.
 *
 * @param string $tid_vid_duple
 *   A string containing the D6 term ID (TID) and vocabulary ID (VID)
 *   delimited by '\'.  This gets around a limitation that the 'callback'
 *   process can only pass a single argument.
 *
 * @return integer
 *   The term ID we want to use, or 0 to drop this term.
 */
function sw_migrate_term_id_map($tid_vid_duple) {
  list ($tid, $vid) = explode('\\', $tid_vid_duple);
  switch ($vid) {
    case 1: // 2.0 Department ("Section" in 3.0)
      return sw_migrate_section_id_map($tid);

    case 10: // Story type
      // Analysis: will be re-purposed into 'Custom'
      if ($tid == 391) {
        return $tid;
      }
      return sw_migrate_story_type_id_map($tid);

      // All other vocabularies, we want to create all terms.
    default:
      return $tid;
  }
}

/**
 * Callback function to deal with department/section taxonomy term IDs.
 *
 * This prunes terms that we no longer need in SW 3.0.
 *
 * @param integet $tid
 *   The term ID (TID) of the SW 2.0 Department.
 *
 * @return integer
 *   The term ID we want to use for the SW 3.0 Section, or 0 to drop this term.
 */
function sw_migrate_section_id_map($tid) {
  switch ($tid) {
    case 6:     // History and Traditions
    case 7:     // Labor
    case 8:     // Activist News
    case 9:     // Readers' Views
    case 11:    // Editorials
    case 17255: // Obrero Socialista
      return $tid;
      // Otherwise, drop the term.
    default:
      return 0;
  }
}

/**
 * Callback function to deal with story type taxonomy term IDs.
 *
 * This prunes terms that we no longer need in SW 3.0.
 *
 * @param integet $tid
 *   The term ID (TID) of the SW 2.0 Story type.
 *
 * @return integer
 *   The term ID we want to use for the SW 3.0 story type, or 0 to drop this term.
 */
function sw_migrate_story_type_id_map($tid) {
  switch ($tid) {
    case 393:   // Interview
    case 4556:  // Obituary
    case 2922:  // Roundtable
      return $tid;
      // Otherwise, drop the term.
    default:
      return 0;
  }
}

/**
 * Migrate callback function to (potentially) rename taxonomy terms.
 *
 * @param string $tid_name_duple
 *   A string containing the D6 term ID (TID) and term name delimited by '\'.
 *   This gets around a limitation that the 'callback' process can only pass a
 *   single argument.
 *
 * @return string
 *   The name we want to use for this term.
 */
function sw_migrate_term_name_map($tid_name_duple) {
  list ($tid, $name) = explode('\\', $tid_name_duple);
  switch ($tid) {
    case 391:
      return 'Custom';

    default:
      return $name;
  }
}

/**
 * Migrate callback function to (potentially) remap node/taxonomy term associations.
 *
 * @param integer $tid
 *   The term ID we're about to associate with a node.
 *
 * @return integer
 *   The term ID we actually want to use, or 0 to drop this term/node association.
 */
function sw_migrate_term_node_map($tid) {
  switch ($tid) {
    // Subterms of 'History and Traditions' are merging into their parent term.
    case 14:     // History/Paul D'Amato
    case 11172:  // History/Todd Chretien
      return 6;
      
    // 'Analysis' story type. This is being ditched in SW 3.0.  However, we're
    // converting this tid into the 'Custom' story type (so all the custom
    // code can already know what the ID will be). So, any story that is
    // classified with this should ignore it and have no story type.
    case 391:
      return 0;
  }

  // Otherwise, leave it alone and use whatever we were given. The migration
  // will check against the successfully imported terms, so other sections
  // and story types that were purged will be ignored.
  return $tid;
}

/**
 * Migrate callback function to try to find the first <dme:img> tag.
 *
 * This is used to populate field_main_image.
 *
 * @param string $body
 *   The D6 value of field_body.
 *
 * @return integer
 *   The media ID of the main image for this story (or 0 if there is none).
 */
function sw_migrate_find_first_dme_img($body) {
  $matches = [];
  return preg_match('@<dme:img nid=(\d+)@', $body, $matches) ? $matches[1] : 0;
}

/**
 * Migrate callback function to rewrite the D6 body field on story nodes.
 *
 * - Rewrites long chains of '- - -'... into <hr> tags.
 * - Rewrites <dme> tags into <drupal-entity> tags and moves them down to the
 *   first paragraph break 1000 characters or more below where they are now.
 * - Avoids placing <drupal-entity> tags inside a <blockquote>.
 *
 * @param string $sw2_body
 *   The SW 2.0 (Drupal 6) value of field_body.
 *
 * @return string
 *   The appropriate value for field_body in SW 3.0 (D8).
 */
function sw_migrate_rewrite_story_body($sw2_body) {
  // Replace 3 or more instances of '- ' and an optional trailing '-' with '<hr>':
  $sw2_body = preg_replace('#(- ){3,}(-)?#', '<hr>', $sw2_body);

  // Split the body into an array for easier DME tag re-positioning.
  // We split on 2 line breaks (\R matches \n, \r or \r\n).
  // We don't want to split on single line breaks, since for example, we want
  // to keep all this together as a single paragraph:
  // <blockquote>
  // Whatever the quote is.
  // </blockquote>
  $sw2_body = preg_split('/(\R){2}/', $sw2_body);

  // Build up the array of paragraphs we want for the 3.0 body.
  $sw3_body = [];
  $pending_embed_tags = [];
  $current_embed_offset = 0;
  $inside_blockquote = FALSE;
  foreach ($sw2_body as $para) {
    $matches = [];
    if (preg_match('@<dme:(box|img|series)[^>]*>@', $para, $matches)) {
      switch ($matches[1]) {
        case 'box':
          $pending_embed_tags[] = sw_migrate_rewrite_dme_box($para);
          break;

        case 'img':
          $pending_embed_tags[] = sw_migrate_rewrite_dme_img($para);
          break;

        case 'series':
          // @todo Are we going to re-write these?
          $pending_embed_tags[] = $para;
          break;
      }
    }
    else {
      // If a paragraph begins with optional whitespace, exactly two hyphens,
      // and more optional whitespace, replace all that with the bullet point
      // span and a single space.
      $sw3_body[] = preg_replace('#^(\s*--\s*)#', '<span class="bullet"></span> ', $para);
      // Count the real characters (not include HTML tags) of this paragraph.
      $current_embed_offset += strlen(strip_tags($para));
      // See if this paragraph is opening a blockquote.
      if (strpos($para, '<blockquote>') !== FALSE) {
        $inside_blockquote = TRUE;
      }
      // If it's a 1 paragraph quote that closes it, or if it's the end of a
      // multi-paragraph blockquote, we're no longer inside a blockquote.
      if (strpos($para, '</blockquote>') !== FALSE) {
        $inside_blockquote = FALSE;
      }
    }
    if (!$inside_blockquote && $current_embed_offset >= 1000 && count($pending_embed_tags) > 0) {
      $sw3_body[] = array_shift($pending_embed_tags);
      $current_embed_offset = 0;
    }
  }
  return implode("\r\n\r\n", $sw3_body);
}

/**
 * Helper function to re-write SW 2.0 DME box tags into <drupal-embed>.
 *
 * @param string $dme_box
 *   The SW 2.0 DME box tag to re-write.
 *
 * @return string
 *   The appropriate <drupal-embed> tags for SW 3.0.
 */
function sw_migrate_rewrite_dme_box($dme_box) {
  $nid = [];
  if (preg_match('@<dme:box nid=(\d+)[^>]*>@', $dme_box, $nid)) {
    return '<drupal-entity data-entity-type="node" data-entity-id="'
      . $nid[1] . '" data-view-mode="default"></drupal-entity>';
  }
}

/**
 * Helper function to re-write SW 2.0 DME img tags into <drupal-embed>.
 *
 * @param string $dme_img
 *   The SW 2.0 DME img tag to re-write.
 *
 * @return string
 *   The appropriate <drupal-embed> tags for SW 3.0.
 */
function sw_migrate_rewrite_dme_img($dme_img) {
  $embed_attrs = [];
  $nid = [];
  if (preg_match('@<dme:img nid=(\d+)[^>]*>@', $dme_img, $nid)) {
    $embed_attrs[] = 'data-entity-type="media"';
    $embed_attrs[] = 'data-entity-id="' . $nid[1] . '"';
    $view_mode = 'embed';
    $size = [];
    if (preg_match('@.*size=(\d+)@', $dme_img, $size)) {
      if ($size[1] > 425) {
        $view_mode = 'embed_wide';
      }
    }
    $embed_attrs[] = 'data-view-mode="' . $view_mode . '"';
    $caption = [];
    if (preg_match('@.*caption="([^"]+)"@', $dme_img, $caption)) {
      $embed_attrs[] = 'data-caption="' . $caption[1] . '"';
    }
    return '<drupal-entity ' . implode(' ', $embed_attrs) . '></drupal-entity>';
  }
}
